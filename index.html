<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Images + Audio to Video Converter</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background-color: #f4f4f4;
      color: #333;
      line-height: 1.6;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: #fff;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(0,0,0,0.1);
    }
    h1, h2 {
      color: #555;
      text-align: center;
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
    }
    input[type="file"], input[type="number"], select {
      display: block;
      width: 100%;
      padding: 10px;
      margin-bottom: 15px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box; /* Added for consistent padding */
    }
    input[type="file"]::-webkit-file-upload-button {
      padding: 10px 15px;
      border: none;
      background-color: #5cb85c;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      margin-right: 10px; /* Added spacing */
    }
    input[type="file"]::-webkit-file-upload-button:hover {
      background-color: #4cae4c;
    }
    button {
      display: block;
      width: 100%;
      padding: 12px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
      margin-top: 20px;
    }
    button:hover {
      background-color: #0056b3;
    }
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    #progress-container, #log-container, #output-container {
      margin-top: 25px;
      padding: 15px;
      border: 1px solid #eee;
      border-radius: 4px;
      background-color: #f9f9f9;
    }
    #progress-bar-container {
      width: 100%;
      background-color: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    #progressBar {
      width: 0%;
      height: 20px;
      background-color: #4caf50;
      text-align: center;
      line-height: 20px;
      color: white;
      font-size: 12px;
      transition: width 0.2s ease-out;
    }
    #progress-text {
        font-size: 0.9em;
        color: #666;
        text-align: center;
    }
    #log, #output {
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.9em;
      background-color: #fff;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    #output-video {
      display: block;
      max-width: 100%;
      margin-top: 15px;
      border-radius: 4px;
    }
    .output-section h2 {
        margin-bottom: 10px;
        font-size: 1.2em;
        color: #333;
        text-align: left;
    }
    a.download-link {
        display: inline-block;
        margin-top: 10px;
        padding: 8px 15px;
        background-color: #28a745;
        color: white;
        text-decoration: none;
        border-radius: 4px;
        font-size: 0.9em;
        transition: background-color 0.3s ease;
    }
    a.download-link:hover {
        background-color: #218838;
    }
    .file-info {
        font-size: 0.8em;
        color: #777;
        margin-top: -10px; /* Adjust spacing */
        margin-bottom: 15px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Images + Audio to Video Converter</h1>
    <p>This tool combines sequentially named image files and an audio file into a video. The video duration will match the audio duration.</p>

    <label for="imageFiles">Select Image Files (must be sequentially named, e.g., img001.png, img002.png...):</label>
    <input type="file" id="imageFiles" multiple accept="image/*">
    <div class="file-info">Select all image files for the sequence. They will be sorted alphabetically. Ensure consistent naming and padding (e.g., 001, 002 vs 1, 2).</div>

    <label for="audioFile">Select Audio File:</label>
    <input type="file" id="audioFile" accept="audio/*">
    <div class="file-info" id="audio-duration-info" style="display: none;"></div> <label for="outputFormat">Output Format:</label>
    <select id="outputFormat">
      <option value="mp4">MP4 (H.264 + AAC)</option>
      <option value="webm">WEBM (VP9 + Opus)</option>
      <option value="mov">MOV (H.264 + AAC)</option>
      </select>

    <button id="startButton" disabled>Load FFmpeg & Start</button>

    <div id="progress-container" style="display: none;">
      <h2>Progress</h2>
      <div id="progress-bar-container">
        <div id="progressBar">0%</div>
      </div>
      <div id="progress-text">Processing...</div>
    </div>

    <div id="log-container" style="display: none;">
      <h2>FFmpeg Log</h2>
      <pre id="log"></pre>
    </div>

    <div id="output-container" class="output-section" style="display: none;">
      <h2>Output</h2>
      <video id="output-video" controls style="display: none;"></video>
      <div id="output-message"></div>
      <a id="downloadLink" class="download-link" style="display: none;" download="output.mp4">Download Video</a>
    </div>
  </div>

  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.min.js"></script>
  <script>
    const { FFmpeg } = FFmpegWASM; // Assuming ffmpeg.min.js loaded FFmpegWASM globally
    let ffmpegInstance = null;

    const imageInput = document.getElementById('imageFiles');
    const audioInput = document.getElementById('audioFile');
    // const imageDurationInput = document.getElementById('imageDuration'); // Removed
    const outputFormatSelect = document.getElementById('outputFormat');
    const startButton = document.getElementById('startButton');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progress-text');
    const logElement = document.getElementById('log');
    const outputVideo = document.getElementById('output-video');
    const outputMessage = document.getElementById('output-message');
    const downloadLink = document.getElementById('downloadLink');
    const progressContainer = document.getElementById('progress-container');
    const logContainer = document.getElementById('log-container');
    const outputContainer = document.getElementById('output-container');
    const audioDurationInfo = document.getElementById('audio-duration-info');


    let targetTotalDuration = 0; // Store target duration (from audio) for progress calculation

    // --- Function to get Audio Duration ---
    async function getAudioDuration(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(e) {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          audioContext.decodeAudioData(e.target.result, function(buffer) {
            resolve(buffer.duration); // Duration in seconds
          }, function(err) {
            console.error("Error decoding audio data:", err);
            reject("Could not decode audio file to get duration.");
          });
        };
        reader.onerror = function(e) {
          console.error("FileReader error:", e);
          reject("Could not read audio file.");
        };
        reader.readAsArrayBuffer(file);
      });
    }

    // --- Function to Load FFmpeg ---
    async function loadFFmpeg() {
        if (ffmpegInstance) return true; // Already loaded

        startButton.textContent = 'Loading FFmpeg Core...';
        startButton.disabled = true;
        console.log('Creating FFmpeg instance...');

        try {
            ffmpegInstance = new FFmpeg();
            logElement.textContent = "Loading FFmpeg-core...\n";

            // --- Event Listeners ---
            ffmpegInstance.on('log', ({ type, message }) => {
                // console.log(`[${type}] ${message}`); // Optional: keep console log
                logElement.textContent += message + "\n";
                logElement.scrollTop = logElement.scrollHeight; // Auto-scroll
                logContainer.style.display = 'block';
            });

            ffmpegInstance.on('progress', ({ progress, time }) => {
                // time is in milliseconds in newer ffmpeg.wasm versions
                let percentage = 0;
                if (targetTotalDuration > 0 && time) {
                    // Use targetTotalDuration (audio duration in ms)
                    percentage = Math.min(100, Math.max(0, (time / (targetTotalDuration * 1000)) * 100));
                } else if (progress) {
                    // Fallback using progress if time or duration isn't reliable
                    percentage = Math.min(100, Math.max(0, progress * 100));
                }
                // Ensure percentage is a valid number before updating UI
                if (!isNaN(percentage)) {
                    progressBar.style.width = percentage.toFixed(1) + '%';
                    progressBar.textContent = percentage.toFixed(1) + '%';
                    progressText.textContent = `Processing... (${percentage.toFixed(1)}%)`;
                    progressContainer.style.display = 'block';
                } else {
                    // Handle cases where percentage calculation might fail initially
                    progressBar.style.width = '0%';
                    progressBar.textContent = '0%';
                    progressText.textContent = 'Processing...';
                    progressContainer.style.display = 'block';
                }
            });

            // --- Load Core ---
            // Using default URLs which unpkg should resolve correctly
            await ffmpegInstance.load();

            console.log('FFmpeg core loaded successfully.');
            logElement.textContent += "FFmpeg core loaded.\n";
            startButton.textContent = 'Start Conversion';
            startButton.disabled = false; // Enable start only after loading
            return true;
        } catch (error) {
            console.error('Error loading FFmpeg:', error);
            startButton.textContent = 'Error Loading FFmpeg';
            startButton.disabled = true;
            logElement.textContent += `\n--- ERROR LOADING FFMPEG ---\n${error}\n---------------------------\n`;
            logContainer.style.display = 'block';
            return false;
        }
    }

    // --- Function to Run Conversion ---
    async function convertFiles() {
      if (!ffmpegInstance || !ffmpegInstance.loaded) {
        alert('FFmpeg is not loaded. Please wait or click the button again.');
        return;
      }
      if (imageInput.files.length === 0) {
        alert('Please select image files.');
        return;
      }
      if (audioInput.files.length !== 1) {
        alert('Please select exactly one audio file.');
        return;
      }

      startButton.disabled = true;
      startButton.textContent = 'Processing...';
      progressContainer.style.display = 'block';
      logContainer.style.display = 'block';
      outputContainer.style.display = 'none';
      outputVideo.style.display = 'none';
      outputVideo.src = '';
      if (downloadLink.href && downloadLink.href.startsWith('blob:')) { // Check if it's a blob URL
        URL.revokeObjectURL(downloadLink.href);
      }
      downloadLink.href = '#';
      downloadLink.style.display = 'none';
      outputMessage.textContent = '';
      logElement.textContent = ''; // Clear previous logs
      progressBar.style.width = '0%';
      progressBar.textContent = '0%';
      progressText.textContent = 'Preparing files...';
      progressBar.style.backgroundColor = '#4caf50'; // Reset color on new run
      targetTotalDuration = 0; // Reset duration

      const audioFile = audioInput.files[0];
      let audioDurationInSeconds = 0;

      try {
        // --- Get Audio Duration ---
        progressText.textContent = 'Analyzing audio duration...';
        try {
            audioDurationInSeconds = await getAudioDuration(audioFile);
            if (isNaN(audioDurationInSeconds) || audioDurationInSeconds <= 0) {
                throw new Error("Invalid audio duration obtained.");
            }
            targetTotalDuration = audioDurationInSeconds; // Set for progress bar
            console.log(`Detected audio duration: ${audioDurationInSeconds.toFixed(3)} seconds`);
            audioDurationInfo.textContent = `Audio Duration: ${audioDurationInSeconds.toFixed(2)}s`;
            audioDurationInfo.style.display = 'block';
        } catch (err) {
            console.error("Failed to get audio duration:", err);
            alert(`Error: Failed to get audio duration. ${err}`);
            throw new Error(`Failed to get audio duration: ${err}`); // Propagate error
        }


        // --- Write files to FFmpeg virtual filesystem ---
        console.log('Writing files to virtual filesystem...');
        progressText.textContent = 'Uploading images...';

        // Sort image files alphabetically
        const imageFiles = Array.from(imageInput.files).sort((a, b) => a.name.localeCompare(b.name));

        if (imageFiles.length === 0) {
            throw new Error("No image files selected or sorted correctly.");
        }
        const numImages = imageFiles.length;

        const firstImageName = imageFiles[0].name;
        // Robust pattern detection (handle cases without numbers better)
        const nameParts = firstImageName.match(/^(.*?)(\d+)(\.\w+)$/);
        let inputPattern = '';
        let imageExtension = '.png'; // Default extension

        if (nameParts) {
            const prefix = nameParts[1];
            const numberString = nameParts[2];
            const suffix = nameParts[3];
            const padding = numberString.length;
            // Assuming starting number is detected correctly, usually 1 or 0
            const startNumber = parseInt(numberString, 10);
            inputPattern = `${prefix}%0${padding}d${suffix}`;
            imageExtension = suffix;
            console.log(`Detected image pattern: ${inputPattern} (starting near ${startNumber})`);
        } else {
            // Fallback if no clear number sequence found
            console.warn("Could not detect standard image sequence naming (e.g., img001.png). Using fallback pattern 'image-%d.ext'. Ensure files are named like image-1.png, image-2.png etc.");
             const firstExt = firstImageName.includes('.') ? firstImageName.substring(firstImageName.lastIndexOf('.')) : '.png';
             inputPattern = `image-%d${firstExt}`;
             imageExtension = firstExt;
             // Requires renaming files in the virtual FS if using this fallback
        }


        for (let i = 0; i < imageFiles.length; i++) {
          const file = imageFiles[i];
          let targetFilename = file.name; // Default: use original name
          if (nameParts) {
             // If pattern detected, rename to ensure sequence matches %0Nd
             const prefix = nameParts[1];
             const suffix = nameParts[3];
             const padding = nameParts[2].length;
             const startNumber = parseInt(nameParts[2], 10); // Get the starting number from the first file detected
             // Generate filename based on index relative to startNumber OR just 1-based index
             // Using 1-based index is safer if startNumber detection is tricky
             targetFilename = `${prefix}${(i + 1).toString().padStart(padding, '0')}${suffix}`;
          } else {
              // If using fallback pattern, rename files sequentially
              targetFilename = `image-${i + 1}${imageExtension}`;
          }
          console.log(`Writing image ${i + 1}/${numImages}: ${file.name} as ${targetFilename}`);
          const data = await readFileAsUint8Array(file);
          await ffmpegInstance.writeFile(targetFilename, data);
        }

        progressText.textContent = 'Uploading audio...';
        const audioFilename = 'input_audio' + (audioFile.name.includes('.') ? audioFile.name.substring(audioFile.name.lastIndexOf('.')) : '.tmp'); // Use .tmp or a generic name
        console.log(`Writing audio: ${audioFile.name} as ${audioFilename}`);
        const audioData = await readFileAsUint8Array(audioFile);
        await ffmpegInstance.writeFile(audioFilename, audioData);

        // --- Construct FFmpeg Command ---
        // Calculate required frame rate for images to match audio duration
        const calculatedFrameRate = numImages / audioDurationInSeconds;
        console.log(`Calculated image frame rate: ${calculatedFrameRate.toFixed(3)} fps`);

        const outputFormat = outputFormatSelect.value;
        const outputFilename = `output.${outputFormat}`;

        // Codecs map
        const codecMap = {
            mp4: { v: 'libx264', a: 'aac' },
            webm: { v: 'libvpx-vp9', a: 'libopus' },
            mov: { v: 'libx264', a: 'aac' },
            // avi: { v: 'mpeg4', a: 'libmp3lame' } // Example if added back
        };
        const selectedCodecs = codecMap[outputFormat] || codecMap.mp4; // Default to mp4 codecs


        const command = [
          // Input image sequence options
          '-framerate', calculatedFrameRate.toString(), // Use calculated rate
          '-i', inputPattern,                       // Image sequence pattern

          // Input audio options
          '-i', audioFilename,                      // Audio file

          // Output options
          '-vf', 'scale=trunc(iw/2)*2:trunc(ih/2)*2,format=yuv420p', // Ensure even dimensions and yuv420p pix_fmt for broad compatibility
        //   '-pix_fmt', 'yuv420p',                 // Moved into vf filter for robustness

          // Video codec
          '-c:v', selectedCodecs.v,
          '-preset', 'medium', // Balance between speed and quality
          '-crf', '23',        // Constant Rate Factor (quality, lower is better, 18-28 is common)

          // Audio codec
          '-c:a', selectedCodecs.a,
          '-b:a', '128k',      // Audio bitrate

          // *** Explicitly set duration and remove shortest ***
          '-t', audioDurationInSeconds.toString(),  // Set output duration to audio duration

          // Removed: '-shortest',                     // No longer needed

          // Output file
          outputFilename
        ];

        // Handle single image case slightly differently if needed (though framerate approach should work)
        // if (numImages === 1) {
        //    console.log("Single image detected, adjusting command slightly for static image.");
        //    command.splice(command.indexOf('-framerate'), 2); // Remove -framerate and its value
        //    command.splice(command.indexOf('-i', command.indexOf(inputPattern)), 1, inputPattern); // Keep input pattern
        //    command.unshift('-loop', '1'); // Add loop before the image input
        //    // Optionally add a standard output frame rate like -r 30 if desired
        //    // command.push('-r', '30');
        // }


        console.log('Executing FFmpeg command:', command.join(' '));
        progressText.textContent = 'Running FFmpeg conversion...';
        logElement.textContent += `\n--- Starting FFmpeg ---\nCommand: ffmpeg ${command.join(' ')}\n-----------------------\n`;


        // --- Execute FFmpeg ---
        await ffmpegInstance.exec(...command); // Use spread syntax for exec

        console.log('FFmpeg execution finished.');
        progressText.textContent = 'Conversion complete. Reading output file...';

        // --- Read Output File ---
        const outputData = await ffmpegInstance.readFile(outputFilename);
        console.log(`Output file read successfully (${outputData.length} bytes).`);

        // --- Display Output ---
        const mimeTypeMap = {
            'mp4': 'video/mp4',
            'webm': 'video/webm',
            'mov': 'video/quicktime',
            'avi': 'video/x-msvideo'
        };
        const mimeType = mimeTypeMap[outputFormat] || 'video/mp4';

        const videoBlob = new Blob([outputData.buffer], { type: mimeType });
        const videoUrl = URL.createObjectURL(videoBlob);

        outputVideo.src = videoUrl;
        outputVideo.style.display = 'block';
        downloadLink.href = videoUrl;
        downloadLink.download = outputFilename;
        downloadLink.style.display = 'inline-block';
        outputMessage.textContent = 'Conversion successful!';
        outputContainer.style.display = 'block';
        progressText.textContent = 'Done!';

        // --- Cleanup (Optional but good practice) ---
        console.log('Cleaning up virtual filesystem...');
        progressText.textContent = 'Cleaning up...';
        try {
          // Delete input images
          for (let i = 0; i < imageFiles.length; i++) {
              let targetFilename = file.name; // Default: use original name
                if (nameParts) {
                    const prefix = nameParts[1];
                    const suffix = nameParts[3];
                    const padding = nameParts[2].length;
                    targetFilename = `${prefix}${(i + 1).toString().padStart(padding, '0')}${suffix}`;
                } else {
                    // If using fallback pattern, rename files sequentially
                    targetFilename = `image-${i + 1}${imageExtension}`;
                }
                await ffmpegInstance.deleteFile(targetFilename);
          }
          // Delete input audio
          await ffmpegInstance.deleteFile(audioFilename);
          // Delete output (though often not necessary if just reading)
          // await ffmpegInstance.deleteFile(outputFilename);
          console.log('Virtual filesystem cleanup complete.');
        } catch (cleanupError) {
            console.warn('Error during virtual filesystem cleanup (files might already be gone):', cleanupError);
        }
        progressText.textContent = 'Complete!';

      } catch (error) {
        console.error('Error during conversion process:', error);
        logElement.textContent += `\n--- ERROR DURING CONVERSION ---\n${error}\n-----------------------------\n`;
        logContainer.style.display = 'block';
        outputMessage.textContent = `Error: ${error.message || error}`;
        outputContainer.style.display = 'block';
        progressText.textContent = 'Error!';
        progressBar.style.backgroundColor = '#dc3545'; // Indicate error with red progress bar
      } finally {
        startButton.disabled = false;
        startButton.textContent = 'Start Conversion';
        // Reset progress bar color if it was red
        // progressBar.style.backgroundColor = '#4caf50'; // Done at the beginning of the try block now
      }
    }

    // Helper to read file as Uint8Array
    function readFileAsUint8Array(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = event => {
          resolve(new Uint8Array(event.target.result));
        };
        reader.onerror = error => {
            console.error("File Reader Error: ", error);
            reject(error);
        };
        reader.readAsArrayBuffer(file);
      });
    }

    // --- Event Listeners ---
    startButton.addEventListener('click', async () => {
        // Load FFmpeg first if not already loaded
        const loaded = await loadFFmpeg();
        if (loaded) {
            convertFiles(); // Then run conversion
        } else {
            alert("FFmpeg failed to load. Check the console for errors.");
        }
    });

    // Initial attempt to load FFmpeg when the page loads might be desired
    // window.addEventListener('load', async () => {
    //     await loadFFmpeg(); // Try loading immediately
    // });
    // Or keep it simple: only load on first click
     window.addEventListener('load', () => {
      startButton.disabled = false; // Enable button, loading will happen on click
      startButton.textContent = 'Start Conversion';
    });


    outputFormatSelect.addEventListener('change', () => {
      downloadLink.download = `output.${outputFormatSelect.value}`;
    });

    // Optional: Show audio duration when file is selected
    audioInput.addEventListener('change', async (event) => {
        if (event.target.files.length > 0) {
            const file = event.target.files[0];
            audioDurationInfo.textContent = 'Fetching audio duration...';
            audioDurationInfo.style.display = 'block';
             try {
                const duration = await getAudioDuration(file);
                if (!isNaN(duration) && duration > 0) {
                    audioDurationInfo.textContent = `Audio Duration: ${duration.toFixed(2)}s`;
                    targetTotalDuration = duration; // Also set it here for progress
                } else {
                    audioDurationInfo.textContent = 'Could not get audio duration.';
                    targetTotalDuration = 0;
                }
            } catch (err) {
                audioDurationInfo.textContent = `Error getting duration: ${err}`;
                targetTotalDuration = 0;
            }
        } else {
             audioDurationInfo.style.display = 'none';
             targetTotalDuration = 0;
        }
    });


  </script>
</body>
</html>
