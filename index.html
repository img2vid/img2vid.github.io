<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulk Images + Audio to Video Converter</title>
    <style>
        /* --- CSS Styles (Unchanged) --- */
        body {
            font-family: sans-serif;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px; /* Wider for multiple jobs */
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #555;
            text-align: center;
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px; /* Smaller margin */
            font-weight: bold;
        }
        input[type="file"], input[type="number"], select {
            display: block;
            width: 100%;
            padding: 8px; /* Smaller padding */
            margin-bottom: 10px; /* Smaller margin */
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.9em;
        }
        input[type="file"]::-webkit-file-upload-button {
            padding: 8px 12px; /* Smaller padding */
            border: none;
            background-color: #5cb85c;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-right: 10px;
        }
        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #4cae4c;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            margin-right: 10px; /* Margin between buttons */
            margin-bottom: 10px; /* Space below buttons */
        }
        button.primary {
            background-color: #007bff;
            color: white;
            width: auto; /* Allow natural width */
        }
        button.primary:hover {
            background-color: #0056b3;
        }
        button.secondary {
            background-color: #6c757d;
            color: white;
            width: auto;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
         button.danger {
            background-color: #dc3545;
            color: white;
            width: auto;
            float: right; /* Position remove button */
        }
        button.danger:hover {
            background-color: #c82333;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #jobs-container {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }

        .job-slot {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            background-color: #f9f9f9;
            position: relative; /* For positioning remove button */
        }
        .job-slot h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #444;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .job-controls {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Responsive grid */
             gap: 15px; /* Space between grid items */
             margin-bottom: 15px;
        }

        #overall-progress-container, #log-container, #overall-output-container {
            margin-top: 25px;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #f0f0f0; /* Different background */
        }
        #overall-progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        #overallProgressBar {
            width: 0%;
            height: 20px;
            background-color: #4caf50;
            text-align: center;
            line-height: 20px;
            color: white;
            font-size: 12px;
            transition: width 0.2s ease-out;
        }
        #overall-progress-text {
            font-size: 0.9em;
            color: #666;
            text-align: center;
        }
        #log {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px; /* More space for logs */
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
            background-color: #fff;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .job-output {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed #ccc;
        }
        .job-output video {
             display: block;
             max-width: 100%;
             max-height: 300px; /* Limit video preview height */
             margin-top: 10px;
             border-radius: 4px;
             background-color: #000; /* Black background for video player */
        }
         .job-output .status {
            font-weight: bold;
            margin-bottom: 5px;
         }
        .job-output .status.success { color: #28a745; }
        .job-output .status.error { color: #dc3545; }
        .job-output .message { font-size: 0.9em; color: #555; }

        a.download-link {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 15px;
            background-color: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }
        a.download-link:hover {
            background-color: #218838;
        }
        .file-info {
            font-size: 0.8em;
            color: #777;
            margin-top: -5px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bulk Images + Audio to Video Converter</h1>
        <p>Add multiple conversion jobs below. For each job, select sequentially named images (e.g., img001.png, img002.png...) and one audio file.</p>

        <div>
             <button id="addJobButton" class="secondary">Add Conversion Job</button>
             <button id="startAllButton" class="primary" disabled>Load FFmpeg & Start All</button>
        </div>

        <div id="jobs-container">
             </div>

        <div id="job-template" style="display: none;">
             <div class="job-slot" data-job-id="">
                 <button class="danger remove-job-button">Remove Job</button>
                 <h3>Job #<span></span></h3>
                 <div class="job-controls">
                     <div>
                         <label for="imageFiles_">Select Image Files:</label>
                         <input type="file" id="imageFiles_" name="imageFiles" multiple accept="image/*">
                         <div class="file-info">Sequentially named (e.g., img001, img002...). Sorted alphabetically.</div>
                     </div>
                     <div>
                          <label for="audioFile_">Select Audio File:</label>
                          <input type="file" id="audioFile_" name="audioFile" accept="audio/*">
                     </div>
                     <div>
                          <label for="imageDuration_">Image Duration (s):</label>
                          <input type="number" id="imageDuration_" name="imageDuration" value="5" min="0.1" step="0.1" placeholder="Leave blank for full audio duration">
                     </div>
                     <div>
                          <label for="outputFormat_">Output Format:</label>
                          <select id="outputFormat_" name="outputFormat">
                              <option value="mp4">MP4</option>
                              <option value="mov">MOV</option>
                          </select>
                     </div>
                 </div>
                 <div class="job-output">
                     <div class="status">Status: Pending</div>
                     <div class="message"></div>
                     <video controls style="display: none;"></video>
                     <a class="download-link" style="display: none;" download="">Download Video</a>
                 </div>
             </div>
        </div>


        <div id="overall-progress-container" style="display: none;">
            <h2>Overall Progress</h2>
            <div id="overall-progress-bar-container">
                <div id="overallProgressBar">0%</div>
            </div>
            <div id="overall-progress-text">Preparing...</div>
        </div>

        <div id="log-container" style="display: none;">
            <h2>FFmpeg Log (Current Job)</h2>
            <pre id="log"></pre>
        </div>

    </div>

    <script src="ffmpeg.min.js"></script>
    <script>
        const { FFmpeg } = FFmpegWASM;
        let ffmpegInstance = null;
        let jobs = []; // Array to hold job data
        let jobCounter = 0; // To assign unique IDs to job slots
        let currentJobIndex = -1; // Index of the job being processed
        let isProcessing = false;

        // --- DOM Elements ---
        const addJobButton = document.getElementById('addJobButton');
        const startAllButton = document.getElementById('startAllButton');
        const jobsContainer = document.getElementById('jobs-container');
        const jobTemplate = document.getElementById('job-template');

        const overallProgressBar = document.getElementById('overallProgressBar');
        const overallProgressText = document.getElementById('overall-progress-text');
        const logElement = document.getElementById('log');

        const overallProgressContainer = document.getElementById('overall-progress-container');
        const logContainer = document.getElementById('log-container');

        // --- FFmpeg Loading ---
        async function loadFFmpeg() {
            if (ffmpegInstance) return true;

            startAllButton.textContent = 'Loading FFmpeg Core...';
            startAllButton.disabled = true;
            addJobButton.disabled = true; // Disable adding jobs while loading
            console.log('Creating FFmpeg instance...');

            try {
                ffmpegInstance = new FFmpeg();

                ffmpegInstance.on('log', ({ type, message }) => {
                    // Only show log if processing is active
                    if (isProcessing) {
                        console.log(`[FFmpeg Job ${currentJobIndex + 1}] [${type}] ${message}`);
                        logElement.textContent += message + "\n";
                        logElement.scrollTop = logElement.scrollHeight;
                        logContainer.style.display = 'block';
                    }
                });

                ffmpegInstance.on('progress', ({ progress, time }) => {
                    // Basic intra-job progress update (can be inaccurate)
                    console.log(`FFmpeg progress (raw):`, { progress, time });
                     if(isProcessing && currentJobIndex >= 0) {
                        const jobProgress = Math.min(100, Math.max(0, (progress || 0) * 100));
                        overallProgressText.textContent = `Processing Job ${currentJobIndex + 1} of ${jobs.length}... (${jobProgress.toFixed(1)}%)`;
                     }
                });

                // Assumes ffmpeg-core files are in the root directory
                await ffmpegInstance.load({
                    coreURL: './ffmpeg-core.js',
                    wasmURL: './ffmpeg-core.wasm'
                });

                console.log('FFmpeg core loaded successfully.');
                startAllButton.textContent = 'Start All Jobs';
                startAllButton.disabled = jobs.length === 0; // Enable only if jobs exist
                addJobButton.disabled = false;
                return true;
            } catch (error) {
                console.error('Error loading FFmpeg:', error);
                startAllButton.textContent = 'Error Loading FFmpeg';
                startAllButton.disabled = true;
                addJobButton.disabled = true;
                alert(`Error loading FFmpeg: ${error.message || error}. Please check console and refresh.`);
                return false;
            }
        }

        // --- Job Management ---
        function addJobSlot() {
            jobCounter++;
            const newJobFragment = jobTemplate.firstElementChild.cloneNode(true);

            // Assign unique IDs and clear inputs
            newJobFragment.dataset.jobId = jobCounter;
            newJobFragment.querySelector('h3 span').textContent = jobCounter;
            newJobFragment.querySelectorAll('label').forEach(label => {
                const oldFor = label.getAttribute('for');
                if (oldFor) label.setAttribute('for', `${oldFor}${jobCounter}`);
            });
            newJobFragment.querySelectorAll('input, select').forEach(input => {
                const oldId = input.id;
                if (oldId) input.id = `${oldId}${jobCounter}`;
                // Reset file inputs and specific defaults
                if (input.type === 'file') {
                    input.value = '';
                } else if (input.name === 'imageDuration') {
                     // Set default value and placeholder for new jobs
                     input.value = '5';
                     input.placeholder = "Leave blank for full audio duration";
                }
            });

            // Add event listener for the remove button
            newJobFragment.querySelector('.remove-job-button').addEventListener('click', () => {
                if (isProcessing) {
                    alert("Cannot remove jobs while processing is active.");
                    return;
                }
                newJobFragment.remove();
                updateStartButtonState();
            });

            jobsContainer.appendChild(newJobFragment);
            updateStartButtonState();
        }

        function updateStartButtonState() {
             const jobSlots = jobsContainer.querySelectorAll('.job-slot');
             // Enable start button only if FFmpeg is loaded and there are jobs
            startAllButton.disabled = !ffmpegInstance || jobSlots.length === 0 || isProcessing;
        }

        // --- File Reading Helper ---
        function readFileAsUint8Array(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = event => resolve(new Uint8Array(event.target.result));
                reader.onerror = error => reject(error);
                reader.readAsArrayBuffer(file);
            });
        }

        // --- Main Processing Logic ---
        async function runAllJobs() {
            if (isProcessing) {
                console.warn("Processing already in progress.");
                return;
            }

            const loaded = await loadFFmpeg();
            if (!loaded) return;

            jobs = []; // Reset jobs array
            const jobSlots = jobsContainer.querySelectorAll('.job-slot');

            // 1. Collect and validate job data from UI
            let hasValidJobs = false;
            jobSlots.forEach((slot, index) => {
                const jobId = slot.dataset.jobId;
                const imageInput = slot.querySelector('input[name="imageFiles"]');
                const audioInput = slot.querySelector('input[name="audioFile"]');
                const durationInput = slot.querySelector('input[name="imageDuration"]');
                const formatSelect = slot.querySelector('select[name="outputFormat"]');
                const statusDiv = slot.querySelector('.job-output .status');
                const messageDiv = slot.querySelector('.job-output .message');
                const videoEl = slot.querySelector('video');
                const downloadEl = slot.querySelector('.download-link');

                // Basic validation
                if (imageInput.files.length === 0) {
                     updateJobStatus(slot, 'Error', 'No image files selected.');
                     return; // Skip this job
                }
                 if (audioInput.files.length !== 1) {
                     updateJobStatus(slot, 'Error', 'Exactly one audio file must be selected.');
                     return; // Skip this job
                 }

                // --- MODIFICATION START: Handle duration input ---
                const durationValue = durationInput.value.trim();
                let imageDurationValue = null; // Default to null (meaning use audio duration)

                if (durationValue !== "") {
                    const parsedDuration = parseFloat(durationValue);
                    if (!isNaN(parsedDuration) && parsedDuration > 0) {
                        imageDurationValue = parsedDuration; // Use the parsed number
                    } else {
                        // Invalid number entered (but not empty), default to 5
                        console.warn(`Job ${jobId}: Invalid duration "${durationValue}", defaulting to 5s.`);
                        imageDurationValue = 5;
                        durationInput.value = '5'; // Update UI to show the default used
                    }
                }
                // If durationValue was "", imageDurationValue remains null
                // --- MODIFICATION END ---

                // Store job data
                jobs.push({
                    id: jobId,
                    slotElement: slot,
                    imageFiles: Array.from(imageInput.files).sort((a, b) => a.name.localeCompare(b.name)), // Sort images
                    audioFile: audioInput.files[0],
                    imageDuration: imageDurationValue, // Store null or the number
                    outputFormat: formatSelect.value,
                    statusDiv,
                    messageDiv,
                    videoEl,
                    downloadEl
                });
                updateJobStatus(slot, 'Pending', ''); // Reset status for valid jobs
                hasValidJobs = true;
            });

            if (!hasValidJobs) {
                alert("No valid jobs found. Please check your selections in each job slot.");
                return;
            }

            // 2. Start Processing
            isProcessing = true;
            startAllButton.disabled = true;
            addJobButton.disabled = true;
            document.querySelectorAll('.remove-job-button').forEach(btn => btn.disabled = true);
            overallProgressContainer.style.display = 'block';
            logContainer.style.display = 'none'; // Hide log initially
            logElement.textContent = ''; // Clear log

            // 3. Process jobs sequentially
            for (let i = 0; i < jobs.length; i++) {
                currentJobIndex = i;
                const job = jobs[i];

                // Update overall progress bar
                const overallProgress = (i / jobs.length) * 100;
                overallProgressBar.style.width = `${overallProgress}%`;
                overallProgressBar.textContent = `${overallProgress.toFixed(0)}%`;
                overallProgressText.textContent = `Starting Job ${i + 1} of ${jobs.length} (ID: ${job.id})...`;
                updateJobStatus(job.slotElement, 'Processing', 'Starting...');

                logElement.textContent = `--- Starting Job ${i + 1} (ID: ${job.id}) ---\n`; // Clear log for new job

                // Process this single job
                const success = await processSingleJob(job);

                if (success) {
                     updateJobStatus(job.slotElement, 'Success', 'Video created successfully.');
                     logElement.textContent += `\n--- Job ${i + 1} (ID: ${job.id}) Finished Successfully ---\n`;
                } else {
                     // Error message already set in processSingleJob
                     logElement.textContent += `\n--- Job ${i + 1} (ID: ${job.id}) FAILED ---\n`;
                }
            }

            // 4. Finish
            isProcessing = false;
            currentJobIndex = -1;
            startAllButton.textContent = 'Start All Jobs';
            startAllButton.disabled = false; // Re-enable based on job count
            addJobButton.disabled = false;
            document.querySelectorAll('.remove-job-button').forEach(btn => btn.disabled = false);
            overallProgressBar.style.width = '100%';
            overallProgressBar.textContent = '100%';
            overallProgressText.textContent = `Processing Complete (${jobs.length} jobs attempted).`;
            updateStartButtonState(); // Final check on start button state
        }

        // --- Process a Single Job ---
        async function processSingleJob(job) {
            // Destructure imageDuration correctly
            const { id, slotElement, imageFiles, audioFile, imageDuration, outputFormat, messageDiv, videoEl, downloadEl } = job;
            const uniquePrefix = `job${id}_`; // Unique prefix for files in this job
            let inputPattern = '';
            let imageExtension = '.png'; // Default
            let tempImageFilenames = [];
            const tempAudioFilename = `${uniquePrefix}audio${getFileExtension(audioFile.name)}`;
            const outputFilename = `${uniquePrefix}output.${outputFormat}`;

            updateJobStatus(slotElement, 'Processing', 'Preparing files...');

            try {
                // --- 1. Write Input Files to FFmpeg FS ---
                messageDiv.textContent = 'Uploading images...';

                // Determine input pattern and write images with unique names
                const firstImageName = imageFiles[0].name;
                // Regex to match name, sequence number, and extension
                const nameParts = firstImageName.match(/^(.*?)(\d+)(\.\w+)$/);

                if (nameParts && imageFiles.length > 1) { // Use pattern only if sequence detected and more than one image
                    const prefix = nameParts[1];
                    const numberString = nameParts[2];
                    const suffix = nameParts[3];
                    const padding = numberString.length;
                    // IMPORTANT: Use the *unique prefix* in the pattern for FFmpeg
                    inputPattern = `${uniquePrefix}${prefix}%0${padding}d${suffix}`;
                    imageExtension = suffix;
                    console.log(`Job ${id}: Detected image sequence pattern: ${inputPattern}`);
                } else {
                    // Fallback for single image or non-standard naming
                    imageExtension = getFileExtension(firstImageName);
                    // Create a simple pattern assuming we'll name them sequentially
                    inputPattern = `${uniquePrefix}image-%d${imageExtension}`;
                    console.log(`Job ${id}: Using fallback pattern: ${inputPattern}`);
                }

                // Write images with consistent naming for the pattern
                 for (let i = 0; i < imageFiles.length; i++) {
                     const file = imageFiles[i];
                     // Generate filename based on the determined pattern structure
                     let targetFilename = inputPattern.replace('%d', (i + 1)).replace(/%\d*d/, (i + 1)); // Basic replacement
                     if (nameParts && imageFiles.length > 1) {
                         const prefix = nameParts[1];
                         const padding = nameParts[2].length;
                         const suffix = nameParts[3];
                         targetFilename = `${uniquePrefix}${prefix}${(i + 1).toString().padStart(padding, '0')}${suffix}`;
                     } else {
                          targetFilename = `${uniquePrefix}image-${i + 1}${imageExtension}`;
                     }

                     tempImageFilenames.push(targetFilename); // Keep track for cleanup
                     // console.log(`Job ${id}: Writing image ${i + 1}/${imageFiles.length}: ${file.name} as ${targetFilename}`);
                     const data = await readFileAsUint8Array(file);
                     await ffmpegInstance.writeFile(targetFilename, data);
                 }


                messageDiv.textContent = 'Uploading audio...';
                // console.log(`Job ${id}: Writing audio: ${audioFile.name} as ${tempAudioFilename}`);
                const audioData = await readFileAsUint8Array(audioFile);
                await ffmpegInstance.writeFile(tempAudioFilename, audioData);

                // --- 2. Construct and Execute FFmpeg Command ---
                 messageDiv.textContent = 'Running conversion...';

                 // --- MODIFICATION START: Build command based on imageDuration ---
                 const command = [];

                 if (imageDuration !== null) {
                     // CASE 1: Specific duration provided
                     console.log(`Job ${id}: Using specified image duration: ${imageDuration}s`);
                     const effectiveFrameRate = `1/${imageDuration}`;
                     command.push(
                         '-framerate', effectiveFrameRate, // Set image framerate based on duration
                         '-i', inputPattern // Image sequence input
                     );
                 } else {
                     // CASE 2: Duration box was empty (imageDuration is null)
                     console.log(`Job ${id}: Using full audio duration (looping images)`);
                     command.push(
                         '-stream_loop', '-1', // Loop the image sequence indefinitely
                         // Optional: add '-r', '25', if default causes issues
                         '-i', inputPattern // Image sequence input
                     );
                 }

                 // Add audio input and common output options
                 command.push(
                     '-i', tempAudioFilename, // Audio input
                     '-vf', 'scale=trunc(iw/2)*2:trunc(ih/2)*2', // Ensure even dimensions for compatibility
                     '-c:v', outputFormat === 'mov' ? 'libx264' : 'libx264', // H.264 codec
                     '-pix_fmt', 'yuv420p', // Pixel format for compatibility
                     '-crf', '23', // Constant Rate Factor (quality vs size)
                     '-preset', 'medium', // Encoding speed vs compression
                     '-c:a', 'aac', // AAC audio codec
                     '-b:a', '128k', // Audio bitrate
                     '-shortest', // Finish encoding when the shortest input ends (audio in the loop case, either in the fixed duration case)
                     outputFilename // Unique output filename
                 );
                 // --- MODIFICATION END ---


                 console.log(`Job ${id}: Executing FFmpeg command:`, command.join(' '));
                 await ffmpegInstance.exec(command);
                 console.log(`Job ${id}: FFmpeg execution finished.`);

                // --- 3. Read Output and Display ---
                messageDiv.textContent = 'Reading output file...';
                const outputData = await ffmpegInstance.readFile(outputFilename);
                console.log(`Job ${id}: Output file read successfully (${outputData.length} bytes).`);

                const mimeTypeMap = { 'mp4': 'video/mp4', 'mov': 'video/quicktime' };
                const mimeType = mimeTypeMap[outputFormat] || 'video/mp4';
                const videoBlob = new Blob([outputData.buffer], { type: mimeType });
                const videoUrl = URL.createObjectURL(videoBlob);

                 // Revoke previous URL if exists to prevent memory leaks
                 if (downloadEl.href && downloadEl.href.startsWith('blob:')) {
                     URL.revokeObjectURL(downloadEl.href);
                 }

                videoEl.src = videoUrl;
                videoEl.style.display = 'block';
                downloadEl.href = videoUrl;
                downloadEl.download = `job${id}_output.${outputFormat}`; // Give a meaningful download name
                downloadEl.style.display = 'inline-block';
                messageDiv.textContent = 'Conversion successful!';

                return true; // Indicate success

            } catch (error) {
                console.error(`Error during conversion for Job ${id}:`, error);
                updateJobStatus(slotElement, 'Error', `Conversion failed: ${error.message || error}`);
                videoEl.style.display = 'none'; // Hide player on error
                downloadEl.style.display = 'none'; // Hide download on error
                if (downloadEl.href && downloadEl.href.startsWith('blob:')) {
                    URL.revokeObjectURL(downloadEl.href); // Clean up potentially created blob URL
                 }
                return false; // Indicate failure

            } finally {
                // --- 4. Cleanup FFmpeg FS for this job ---
                console.log(`Job ${id}: Cleaning up virtual filesystem...`);
                try {
                    for (const filename of tempImageFilenames) {
                        // Check if file exists before deleting (optional, prevents warnings if exec failed early)
                        // if (await ffmpegInstance.exists(filename)) {
                           await ffmpegInstance.deleteFile(filename);
                        // }
                    }
                     // if (await ffmpegInstance.exists(tempAudioFilename)) {
                        await ffmpegInstance.deleteFile(tempAudioFilename);
                     // }
                     // Delete output only after reading it successfully or if it exists after failure
                     // if (await ffmpegInstance.exists(outputFilename)) {
                        await ffmpegInstance.deleteFile(outputFilename);
                     // }
                    console.log(`Job ${id}: Virtual filesystem cleanup complete.`);
                } catch (cleanupError) {
                    console.warn(`Job ${id}: Error during virtual filesystem cleanup:`, cleanupError);
                    // Don't mark the job as failed just because cleanup failed, but log it.
                    messageDiv.textContent += ' (Cleanup warning - see console)';
                }
            }
        }

        // --- UI Update Helpers ---
        function updateJobStatus(slotElement, statusType, message) {
             const statusDiv = slotElement.querySelector('.job-output .status');
             const messageDiv = slotElement.querySelector('.job-output .message');
             statusDiv.textContent = `Status: ${statusType}`;
             statusDiv.className = `status ${statusType.toLowerCase()}`; // Add class for styling
             messageDiv.textContent = message;
        }

        function getFileExtension(filename) {
            const lastDot = filename.lastIndexOf('.');
            if (lastDot === -1) return ''; // No extension
            return filename.substring(lastDot); // Includes the dot
        }


        // --- Initial Setup ---
        window.addEventListener('load', () => {
            addJobButton.disabled = false;
            startAllButton.textContent = 'Load FFmpeg & Start All';
            startAllButton.disabled = true; // Disabled until FFmpeg loads and jobs are added
            // Add the first job slot automatically
            addJobSlot();
             // Attempt to load FFmpeg on page load for faster startup
             // Don't await here, let it load in the background
             loadFFmpeg().then(loaded => {
                 if(loaded) updateStartButtonState();
             });
        });

        addJobButton.addEventListener('click', addJobSlot);
        startAllButton.addEventListener('click', runAllJobs);

    </script>
</body>
</html>
