<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulk Image + Audio to Video Converter</title>
    <style>
        /* CSS styles remain exactly as provided in the original prompt */
        body {
            font-family: sans-serif;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px; /* Wider for multiple jobs */
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #555;
            text-align: center;
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px; /* Smaller margin */
            font-weight: bold;
        }
        input[type="file"], input[type="number"], select {
            display: block;
            width: 100%;
            padding: 8px; /* Smaller padding */
            margin-bottom: 10px; /* Smaller margin */
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.9em;
        }
        input[type="file"]::-webkit-file-upload-button {
            padding: 8px 12px; /* Smaller padding */
            border: none;
            background-color: #5cb85c;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-right: 10px;
        }
        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #4cae4c;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            margin-right: 10px; /* Margin between buttons */
            margin-bottom: 10px; /* Space below buttons */
        }
        button.primary {
            background-color: #007bff;
            color: white;
            width: auto; /* Allow natural width */
        }
        button.primary:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #jobs-container {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }

        .job-slot {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            background-color: #f9f9f9;
            position: relative; /* For positioning remove button */
        }
        .job-slot h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #444;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .job-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Responsive grid */
            gap: 15px; /* Space between grid items */
            margin-bottom: 15px;
        }

        #overall-progress-container, #log-container {
            margin-top: 25px;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #f0f0f0; /* Different background */
        }
        #overall-progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        #overallProgressBar {
            width: 0%;
            height: 20px;
            background-color: #4caf50;
            text-align: center;
            line-height: 20px;
            color: white;
            font-size: 12px;
            transition: width 0.2s ease-out;
        }
        #overall-progress-text {
            font-size: 0.9em;
            color: #666;
            text-align: center;
        }
        #log {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px; /* More space for logs */
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
            background-color: #fff;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .job-output {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed #ccc;
        }
        .job-output video {
            display: block;
            max-width: 100%;
            max-height: 300px; /* Limit video preview height */
            margin-top: 10px;
            border-radius: 4px;
            background-color: #000; /* Black background for video player */
        }
        .job-output .status {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .job-output .status.success { color: #28a745; }
        .job-output .status.error { color: #dc3545; }
        .job-output .status.pending { color: #6c757d; }
        .job-output .status.processing { color: #007bff; }
        .job-output .message { font-size: 0.9em; color: #555; }

        a.download-link {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 15px;
            background-color: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }
        a.download-link:hover {
            background-color: #218838;
        }
        .file-info {
            font-size: 0.8em;
            color: #777;
            margin-top: -5px;
            margin-bottom: 10px;
        }
        #unmatched-files-container {
            margin-top: 20px;
            padding: 15px;
            background-color: #fffbe6;
            border: 1px solid #ffeeba;
            border-radius: 5px;
        }
        #unmatched-files-container h3 {
            margin-top: 0;
            color: #856404;
        }
        #unmatched-files-container ul {
            padding-left: 20px;
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bulk Image + Audio to Video Converter</h1>
        <p>Select multiple image and audio files. The tool will automatically pair files with the <strong>same name</strong> (e.g., <code>"cat.jpg"</code> and <code>"cat.mp3"</code>) to create individual videos.</p>
        
        <div class="job-controls">
             <div>
                <label for="imageFiles">1. Select Image Files:</label>
                <input type="file" id="imageFiles" name="imageFiles" multiple accept="image/*">
            </div>
            <div>
                <label for="audioFiles">2. Select Audio Files:</label>
                <input type="file" id="audioFiles" name="audioFiles" multiple accept="audio/*">
            </div>
            <div>
                <label for="outputFormat">3. Select Output Format:</label>
                <select id="outputFormat" name="outputFormat">
                    <option value="mp4">MP4</option>
                    <option value="mov">MOV</option>
                </select>
            </div>
        </div>

        <div>
            <button id="startProcessingButton" class="primary" disabled>Load FFmpeg & Start Conversion</button>
        </div>

        <div id="jobs-container">
            <!-- Matched jobs will be dynamically inserted here -->
        </div>
        
        <div id="unmatched-files-container" style="display: none;">
            <h3>Unmatched Files</h3>
            <ul id="unmatched-files-list"></ul>
        </div>


        <div id="overall-progress-container" style="display: none;">
            <h2>Overall Progress</h2>
            <div id="overall-progress-bar-container">
                <div id="overallProgressBar">0%</div>
            </div>
            <div id="overall-progress-text">Preparing...</div>
        </div>

        <div id="log-container" style="display: none;">
            <h2>FFmpeg Log (Current Job)</h2>
            <pre id="log"></pre>
        </div>

    </div>

    <!-- This is a template for a single job's UI, it's cloned by JavaScript -->
    <div id="job-template" style="display: none;">
        <div class="job-slot" data-job-id="">
            <h3>Job: <span></span></h3>
            <div class="job-output">
                <div class="status">Status: Pending</div>
                <div class="message"></div>
                <video controls style="display: none;"></video>
                <a class="download-link" style="display: none;" download="">Download Video</a>
            </div>
        </div>
    </div>


    <script src="./ffmpeg.js"></script>
    <script>
        // Note: Using the unpkg CDN for ffmpeg.js for simplicity.
        // For production, you should host these files yourself.
        const { FFmpeg } = FFmpegWASM;
        let ffmpegInstance = null;
        let jobs = []; // Array to hold matched job data
        let isProcessing = false;
        let currentJobIndex = -1;

        // --- DOM Elements ---
        const imageFilesInput = document.getElementById('imageFiles');
        const audioFilesInput = document.getElementById('audioFiles');
        const outputFormatSelect = document.getElementById('outputFormat');
        const startProcessingButton = document.getElementById('startProcessingButton');
        const jobsContainer = document.getElementById('jobs-container');
        const jobTemplate = document.getElementById('job-template');
        const unmatchedContainer = document.getElementById('unmatched-files-container');
        const unmatchedList = document.getElementById('unmatched-files-list');

        const overallProgressContainer = document.getElementById('overall-progress-container');
        const overallProgressBar = document.getElementById('overallProgressBar');
        const overallProgressText = document.getElementById('overall-progress-text');
        const logContainer = document.getElementById('log-container');
        const logElement = document.getElementById('log');

        // --- FFmpeg Loading ---
        async function loadFFmpeg() {
            if (ffmpegInstance && ffmpegInstance.loaded) return true;

            startProcessingButton.textContent = 'Loading FFmpeg Core...';
            startProcessingButton.disabled = true;
            console.log('Creating FFmpeg instance...');

            try {
                ffmpegInstance = new FFmpeg();

                ffmpegInstance.on('log', ({ type, message }) => {
                    if (isProcessing) {
                        console.log(`[FFmpeg Job ${currentJobIndex + 1}] [${type}] ${message}`);
                        logElement.textContent += message + "\n";
                        logElement.scrollTop = logElement.scrollHeight;
                        logContainer.style.display = 'block';
                    }
                });

                ffmpegInstance.on('progress', ({ progress, time }) => {
                    if(isProcessing && currentJobIndex >= 0) {
                        const jobProgress = Math.min(100, Math.max(0, (progress || 0) * 100));
                        overallProgressText.textContent = `Processing Job ${currentJobIndex + 1} of ${jobs.length}... (${jobProgress.toFixed(1)}%)`;
                    }
                });
                
                // Using URLs from CDN for the core files
                const coreURL = "./ffmpeg-core.js";
                const wasmURL = "./ffmpeg-core.wasm";

                await ffmpegInstance.load({ coreURL, wasmURL });

                console.log('FFmpeg core loaded successfully.');
                startProcessingButton.textContent = 'Start Conversion';
                updateStartButtonState(); // Enable if files are selected
                return true;
            } catch (error) {
                console.error('Error loading FFmpeg:', error);
                startProcessingButton.textContent = 'Error Loading FFmpeg';
                startProcessingButton.disabled = true;
                alert(`Error loading FFmpeg: ${error.message || error}. Please check console and refresh.`);
                return false;
            }
        }
        
        // --- File Matching & UI Setup ---
        function matchFilesAndPrepareUI() {
            const imageFiles = Array.from(imageFilesInput.files);
            const audioFiles = Array.from(audioFilesInput.files);

            // Reset state
            jobs = [];
            jobsContainer.innerHTML = '';
            unmatchedList.innerHTML = '';
            unmatchedContainer.style.display = 'none';

            if (imageFiles.length === 0 || audioFiles.length === 0) {
                 updateStartButtonState();
                 return;
            }

            const getBaseName = (filename) => {
                const lastDot = filename.lastIndexOf('.');
                return lastDot === -1 ? filename : filename.substring(0, lastDot);
            };

            const audioMap = new Map(audioFiles.map(file => [getBaseName(file.name), file]));
            const usedAudio = new Set();
            const unmatchedImages = [];
            
            // Match images to audio files
            imageFiles.forEach(imageFile => {
                const baseName = getBaseName(imageFile.name);
                if (audioMap.has(baseName)) {
                    const audioFile = audioMap.get(baseName);
                    // Create a UI element for this job
                    const jobUI = jobTemplate.firstElementChild.cloneNode(true);
                    jobUI.dataset.jobId = baseName;
                    jobUI.querySelector('h3 span').textContent = `${imageFile.name} + ${audioFile.name}`;
                    
                    jobsContainer.appendChild(jobUI);

                    // Add to the processing jobs list
                    jobs.push({
                        id: baseName,
                        imageFile: imageFile,
                        audioFile: audioFile,
                        slotElement: jobUI,
                    });
                    usedAudio.add(audioFile.name);
                } else {
                    unmatchedImages.push(imageFile.name);
                }
            });

            // Find unmatched audio files
            const unmatchedAudio = audioFiles
                .filter(file => !usedAudio.has(file.name))
                .map(file => file.name);

            // Display unmatched files if any
            if (unmatchedImages.length > 0 || unmatchedAudio.length > 0) {
                 unmatchedContainer.style.display = 'block';
                 unmatchedImages.forEach(name => {
                     unmatchedList.innerHTML += `<li>Image: ${name} (no matching audio)</li>`;
                 });
                 unmatchedAudio.forEach(name => {
                     unmatchedList.innerHTML += `<li>Audio: ${name} (no matching image)</li>`;
                 });
            }
            
            updateStartButtonState();
        }

        function updateStartButtonState() {
            // Enable start button only if FFmpeg is loaded and there are matched jobs
            startProcessingButton.disabled = !ffmpegInstance || !ffmpegInstance.loaded || jobs.length === 0 || isProcessing;
        }

        // --- File Reading Helper ---
        function readFileAsUint8Array(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = event => resolve(new Uint8Array(event.target.result));
                reader.onerror = error => reject(error);
                reader.readAsArrayBuffer(file);
            });
        }

        // --- Main Processing Logic ---
        async function runAllJobs() {
            if (isProcessing) return;

            const loaded = await loadFFmpeg();
            if (!loaded) return;

            if (jobs.length === 0) {
                alert("No matched image/audio pairs found to process.");
                return;
            }

            // Set UI to processing state
            isProcessing = true;
            startProcessingButton.disabled = true;
            imageFilesInput.disabled = true;
            audioFilesInput.disabled = true;
            outputFormatSelect.disabled = true;
            
            overallProgressContainer.style.display = 'block';
            logContainer.style.display = 'none';
            logElement.textContent = '';
            overallProgressBar.style.width = '0%';
            overallProgressBar.textContent = '0%';
            overallProgressText.textContent = `Starting processing for ${jobs.length} job(s)...`;
            
            // Reset status for all jobs before starting
            jobs.forEach(job => updateJobStatus(job.slotElement, 'Pending', 'Waiting in queue...'));

            // Process jobs sequentially
            for (let i = 0; i < jobs.length; i++) {
                currentJobIndex = i;
                const job = jobs[i];

                const overallProgress = (i / jobs.length) * 100;
                overallProgressBar.style.width = `${overallProgress}%`;
                overallProgressBar.textContent = `${overallProgress.toFixed(0)}%`;
                overallProgressText.textContent = `Starting Job ${i + 1} of ${jobs.length} (${job.id})...`;
                
                logElement.textContent = `--- Starting Job ${i + 1} (${job.id}) ---\n`;
                logContainer.style.display = 'block';

                const success = await processSingleJob(job);
                
                 if (success) {
                    logElement.textContent += `\n--- Job ${i + 1} (${job.id}) Finished Successfully ---\n`;
                } else {
                    logElement.textContent += `\n--- Job ${i + 1} (${job.id}) FAILED ---\n`;
                    // You can choose to stop on failure by uncommenting the next line
                    // break; 
                }
            }
            
            // Finish
            isProcessing = false;
            currentJobIndex = -1;
            imageFilesInput.disabled = false;
            audioFilesInput.disabled = false;
            outputFormatSelect.disabled = false;
            overallProgressBar.style.width = '100%';
            overallProgressBar.textContent = '100%';
            overallProgressText.textContent = `Processing Complete (${jobs.length} jobs processed).`;
            updateStartButtonState();
        }

        // --- Process a Single Job ---
        async function processSingleJob(job) {
            const { id, slotElement, imageFile, audioFile } = job;
            const outputFormat = outputFormatSelect.value;
            
            const getFileExtension = (filename) => {
                const lastDot = filename.lastIndexOf('.');
                return lastDot === -1 ? '' : filename.substring(lastDot);
            };

            // Unique filenames in FFmpeg's virtual file system
            const tempImageFilename = `img${getFileExtension(imageFile.name)}`;
            const tempAudioFilename = `aud${getFileExtension(audioFile.name)}`;
            const outputFilename = `output.${outputFormat}`;
            
            updateJobStatus(slotElement, 'Processing', 'Preparing files...');

            try {
                // 1. Write input files to FFmpeg FS
                updateJobStatus(slotElement, 'Processing', 'Uploading files...');
                const imageData = await readFileAsUint8Array(imageFile);
                await ffmpegInstance.writeFile(tempImageFilename, imageData);
                const audioData = await readFileAsUint8Array(audioFile);
                await ffmpegInstance.writeFile(tempAudioFilename, audioData);

                // 2. Construct and Execute FFmpeg Command
                updateJobStatus(slotElement, 'Processing', 'Running conversion...');
                
                // This command loops a single image for the duration of the audio
                const command = [
                    '-loop', '1',                      // Loop the image
                    '-i', tempImageFilename,           // Input image
                    '-i', tempAudioFilename,           // Input audio
                    '-c:v', 'libx264',                 // Video codec
                    '-tune', 'stillimage',             // Optimize for static images
                    '-c:a', 'aac',                     // Audio codec
                    '-b:a', '192k',                    // Audio bitrate
                    '-pix_fmt', 'yuv420p',             // Pixel format for compatibility
                    '-shortest',                       // Finish when the shortest input (the audio) ends
                    outputFilename
                ];
                
                console.log(`Job ${id}: Executing FFmpeg command:`, command.join(' '));
                await ffmpegInstance.exec(command);
                console.log(`Job ${id}: FFmpeg execution finished.`);

                // 3. Read Output and Display
                updateJobStatus(slotElement, 'Processing', 'Reading output file...');
                const outputData = await ffmpegInstance.readFile(outputFilename);

                const mimeTypeMap = { 'mp4': 'video/mp4', 'mov': 'video/quicktime' };
                const mimeType = mimeTypeMap[outputFormat] || 'video/mp4';
                const videoBlob = new Blob([outputData.buffer], { type: mimeType });
                const videoUrl = URL.createObjectURL(videoBlob);

                const videoEl = slotElement.querySelector('video');
                const downloadEl = slotElement.querySelector('.download-link');
                videoEl.src = videoUrl;
                videoEl.style.display = 'block';
                downloadEl.href = videoUrl;
                downloadEl.download = `${id}_video.${outputFormat}`;
                downloadEl.style.display = 'inline-block';
                
                const fileSizeMB = (outputData.length / 1024 / 1024).toFixed(2);
                updateJobStatus(slotElement, 'Success', `Video created (${fileSizeMB} MB)`);
                return true;

            } catch (error) {
                console.error(`Error during conversion for Job ${id}:`, error);
                updateJobStatus(slotElement, 'Error', `Conversion failed: ${error.message || 'Check console for details'}`);
                return false;

            } finally {
                // 4. Cleanup FFmpeg FS for this job
                console.log(`Job ${id}: Cleaning up virtual filesystem...`);
                try {
                    await ffmpegInstance.deleteFile(tempImageFilename);
                    await ffmpegInstance.deleteFile(tempAudioFilename);
                    await ffmpegInstance.deleteFile(outputFilename);
                } catch (cleanupError) {
                    console.warn(`Job ${id}: Error during cleanup:`, cleanupError);
                }
            }
        }
        
        // --- UI Update Helper ---
        function updateJobStatus(slotElement, statusType, message) {
            if (!slotElement) return;
            const statusDiv = slotElement.querySelector('.job-output .status');
            const messageDiv = slotElement.querySelector('.job-output .message');
            if (statusDiv) {
                statusDiv.textContent = `Status: ${statusType}`;
                statusDiv.className = `status ${statusType.toLowerCase()}`;
            }
            if (messageDiv) {
                messageDiv.textContent = message;
            }
        }

        // --- Initial Setup & Event Listeners ---
        window.addEventListener('load', () => {
            startProcessingButton.textContent = 'Load FFmpeg & Start Conversion';
            startProcessingButton.disabled = true; 
            // Load FFmpeg immediately for a faster start
            loadFFmpeg();
        });

        imageFilesInput.addEventListener('change', matchFilesAndPrepareUI);
        audioFilesInput.addEventListener('change', matchFilesAndPrepareUI);
        startProcessingButton.addEventListener('click', runAllJobs);

    </script>
</body>
</html>
