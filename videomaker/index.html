<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio ZIP + Image to Videos Converter</title>
    <script src="./jszip.min.js"></script>
    <script src="./ffmpeg.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            padding: 20px;
            background-color: #f0f2f5; /* Softer background */
            color: #333;
            line-height: 1.6;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for long content */
            min-height: 100vh;
        }
        .container {
            width: 100%;
            max-width: 700px; /* Optimized width */
            margin: 20px;
            background: #ffffff;
            padding: 30px;
            border-radius: 12px; /* Softer radius */
            box-shadow: 0 8px 16px rgba(0,0,0,0.1); /* More pronounced shadow */
        }
        h1 {
            color: #1a202c; /* Darker heading */
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.8em; /* Larger title */
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600; /* Bolder labels */
            color: #4a5568; /* Label color */
        }
        input[type="file"], select {
            display: block;
            width: 100%;
            padding: 10px 12px; /* Comfortable padding */
            margin-bottom: 20px; /* More space */
            border: 1px solid #cbd5e0; /* Softer border */
            border-radius: 6px; /* Softer radius */
            box-sizing: border-box;
            font-size: 0.95em;
            background-color: #f7fafc; /* Light input background */
        }
        input[type="file"]::-webkit-file-upload-button {
            padding: 10px 15px;
            border: none;
            background-color: #4299e1; /* Tailwind blue-500 */
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-right: 10px;
            font-weight: 500;
        }
        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #2b6cb0; /* Tailwind blue-700 */
        }
        button {
            padding: 12px 20px; /* Larger buttons */
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600; /* Bolder button text */
            transition: background-color 0.3s ease, box-shadow 0.2s ease;
            margin-top: 10px; /* Space above button */
            width: 100%; /* Full width button */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        button.primary {
            background-color: #48bb78; /* Tailwind green-500 */
            color: white;
        }
        button.primary:hover {
            background-color: #38a169; /* Tailwind green-600 */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:disabled {
            background-color: #a0aec0; /* Tailwind gray-500 */
            color: #e2e8f0; /* Lighter text for disabled */
            cursor: not-allowed;
            box-shadow: none;
        }
        #progress-container, #log-container, #output-zip-container {
            margin-top: 25px;
            padding: 20px;
            border: 1px solid #e2e8f0; /* Softer border */
            border-radius: 8px;
            background-color: #f7fafc; /* Light background for these sections */
        }
        #progress-container h2, #log-container h2, #output-zip-container h2 {
             margin-top: 0;
             margin-bottom: 15px;
             color: #2d3748; /* Darker section titles */
             font-size: 1.25em;
             border-bottom: 1px solid #e2e8f0;
             padding-bottom: 10px;
        }
        #progress-bar-container {
            width: 100%;
            background-color: #e2e8f0; /* Tailwind gray-300 */
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 10px;
            height: 24px; /* Taller progress bar */
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background-color: #4299e1; /* Tailwind blue-500 */
            text-align: center;
            line-height: 24px; /* Vertically center text */
            color: white;
            font-size: 0.85em;
            font-weight: 600;
            transition: width 0.3s ease-out;
        }
        #progress-text {
            font-size: 0.95em;
            color: #4a5568; /* Tailwind gray-700 */
            text-align: center;
        }
        #log {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.85em;
            background-color: #ffffff;
            padding: 15px;
            border: 1px solid #e2e8f0; /* Softer border */
            border-radius: 6px;
            color: #2d3748; /* Darker log text */
        }
        a.download-link {
            display: inline-block;
            margin-top: 10px;
            padding: 10px 18px;
            background-color: #48bb78; /* Tailwind green-500 */
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 600;
            transition: background-color 0.3s ease;
        }
        a.download-link:hover {
            background-color: #38a169; /* Tailwind green-600 */
        }
        .file-info {
            font-size: 0.8em;
            color: #718096; /* Tailwind gray-600 */
            margin-top: -15px; /* Closer to input */
            margin-bottom: 15px;
        }
        .hidden {
            display: none;
        }
         /* Message Box Styles */
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .message-box-content {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        .message-box-content p {
            margin: 0 0 15px 0;
            color: #4a5568;
        }
        .message-box-content button {
            background-color: #4299e1;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            width: auto; /* Not full width */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio ZIP + Image to Videos Converter</h1>
        <p>Upload a ZIP file containing your audio tracks and a single image. Videos will be created for each audio track using the image, then bundled into a downloadable ZIP.</p>

        <div>
            <label for="audioZipInput">Select Audio ZIP File:</label>
            <input type="file" id="audioZipInput" accept=".zip">
            <div class="file-info">A ZIP file containing one or more audio files (e.g., .mp3, .wav, .m4a).</div>
        </div>

        <div>
            <label for="imageInput">Select Single Image File:</label>
            <input type="file" id="imageInput" accept="image/*">
            <div class="file-info">A single image file (e.g., .png, .jpg, .jpeg, .webp).</div>
        </div>
        
        <div>
            <label for="outputFormatSelect">Output Video Format (for all videos):</label>
            <select id="outputFormatSelect">
                <option value="mp4" selected>MP4 (H.264/AAC)</option>
                <option value="mov">MOV (H.264/AAC)</option>
                </select>
        </div>


        <button id="generateButton" class="primary" disabled>Load FFmpeg & Generate</button>

        <div id="progress-container" class="hidden">
            <h2>Processing Progress</h2>
            <div id="progress-bar-container">
                <div id="progressBar">0%</div>
            </div>
            <div id="progress-text">Preparing...</div>
        </div>

        <div id="log-container" class="hidden">
            <h2>FFmpeg Log</h2>
            <pre id="log"></pre>
        </div>

        <div id="output-zip-container" class="hidden">
            <h2>Download Output</h2>
            <p>All generated videos have been bundled into a single ZIP file.</p>
            <a id="downloadZipLink" class="download-link" download="generated_videos.zip">Download Videos ZIP</a>
        </div>
    </div>

    <script>
        const { FFmpeg } = FFmpegWASM;
        let ffmpegInstance = null;
        let isProcessing = false;

        // --- DOM Elements ---
        const audioZipInput = document.getElementById('audioZipInput');
        const imageInput = document.getElementById('imageInput');
        const outputFormatSelect = document.getElementById('outputFormatSelect');
        const generateButton = document.getElementById('generateButton');
        
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progress-text');
        
        const logContainer = document.getElementById('log-container');
        const logElement = document.getElementById('log');
        
        const outputZipContainer = document.getElementById('output-zip-container');
        const downloadZipLink = document.getElementById('downloadZipLink');

        // --- Custom Alert ---
        function showMessage(message) {
            const overlay = document.createElement('div');
            overlay.className = 'message-box-overlay';
            
            const content = document.createElement('div');
            content.className = 'message-box-content';
            
            const text = document.createElement('p');
            text.textContent = message;
            
            const closeButton = document.createElement('button');
            closeButton.textContent = 'OK';
            closeButton.onclick = () => overlay.remove();
            
            content.appendChild(text);
            content.appendChild(closeButton);
            overlay.appendChild(content);
            document.body.appendChild(overlay);
            closeButton.focus();
        }


        // --- FFmpeg Loading ---
        async function loadFFmpeg() {
            if (ffmpegInstance) return true;

            generateButton.textContent = 'Loading FFmpeg Core...';
            generateButton.disabled = true;
            console.log('Creating FFmpeg instance...');

            try {
                ffmpegInstance = new FFmpeg();
                ffmpegInstance.on('log', ({ type, message }) => {
                    if (isProcessing) { // Only show log during active processing
                        console.log(`[FFmpeg] [${type}] ${message}`);
                        logElement.textContent += message + "\n";
                        logElement.scrollTop = logElement.scrollHeight;
                    }
                });

                ffmpegInstance.on('progress', ({ progress, time }) => {
                     // This progress is for the current FFmpeg task (one video).
                     // We'll use overallProgressText for "Video X of Y" type updates.
                    if (isProcessing && progress && typeof progress === 'number') {
                        const currentVideoProgress = Math.min(100, Math.max(0, progress * 100));
                        // Update a more specific progress if needed, e.g., for the current video.
                        // For now, the main progress bar shows overall videos processed.
                        // progressText.textContent = `Processing current video... (${currentVideoProgress.toFixed(1)}%)`;
                        console.log(`FFmpeg task progress: ${currentVideoProgress.toFixed(1)}%`);
                    }
                });

                await ffmpegInstance.load({
                    coreURL: './ffmpeg-core.js', // Adjust path if needed
                    wasmURL: './ffmpeg-core.wasm' // Adjust path if needed
                });

                console.log('FFmpeg core loaded successfully.');
                generateButton.textContent = 'Generate Videos & ZIP';
                updateGenerateButtonState(); // Checks if inputs are ready
                return true;
            } catch (error) {
                console.error('Error loading FFmpeg:', error);
                generateButton.textContent = 'Error Loading FFmpeg';
                generateButton.disabled = true;
                showMessage(`Error loading FFmpeg: ${error.message || error}. Please check console and refresh.`);
                return false;
            }
        }

        function updateGenerateButtonState() {
            const audioFile = audioZipInput.files.length > 0;
            const imageFile = imageInput.files.length > 0;
            if (ffmpegInstance && !isProcessing) {
                generateButton.disabled = !(audioFile && imageFile);
            } else if (!ffmpegInstance) {
                 generateButton.disabled = true; // Keep disabled if FFmpeg not loaded
            }
        }

        // --- File Reading Helpers ---
        function readFileAsUint8Array(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = event => resolve(new Uint8Array(event.target.result));
                reader.onerror = error => reject(error);
                reader.readAsArrayBuffer(file);
            });
        }

        function getAudioDuration(audioFile) { // audioFile is a File object
            return new Promise((resolve, reject) => {
                if (!audioFile || !audioFile.type.startsWith('audio/')) {
                    return reject(new Error("Invalid or missing audio file for duration check."));
                }
                const tempAudio = document.createElement('audio');
                const objectURL = URL.createObjectURL(audioFile);
                tempAudio.preload = 'metadata';

                const cleanup = () => {
                    tempAudio.removeEventListener('loadedmetadata', onLoadedMetadata);
                    tempAudio.removeEventListener('error', onError);
                    URL.revokeObjectURL(objectURL);
                };
                const onLoadedMetadata = () => {
                    const duration = tempAudio.duration;
                    cleanup();
                    if (isNaN(duration) || !isFinite(duration) || duration <= 0) {
                       reject(new Error(`Could not determine a valid positive duration for ${audioFile.name}. Duration: ${duration}`));
                    } else {
                       resolve(duration);
                    }
                };
                const onError = (e) => {
                    cleanup();
                    console.error(`Error loading audio metadata for ${audioFile.name}:`, e);
                    reject(new Error(`Failed to load metadata for ${audioFile.name}. Check file format or content.`));
                };

                tempAudio.addEventListener('loadedmetadata', onLoadedMetadata);
                tempAudio.addEventListener('error', onError);
                tempAudio.src = objectURL;
            });
        }

        function getFileExtension(filename) {
            const lastDot = filename.lastIndexOf('.');
            if (lastDot === -1) return '';
            return filename.substring(lastDot).toLowerCase(); // Includes the dot
        }
        
        function getFilenameWithoutExtension(filename) {
            const lastDot = filename.lastIndexOf('.');
            if (lastDot === -1) return filename;
            return filename.substring(0, lastDot);
        }


        // --- Main Processing Logic ---
        async function generateAndZipVideos() {
            if (isProcessing) {
                showMessage("Processing is already in progress.");
                return;
            }
            if (!audioZipInput.files.length || !imageInput.files.length) {
                showMessage("Please select both an audio ZIP file and an image file.");
                return;
            }

            const ffmpegLoaded = await loadFFmpeg();
            if (!ffmpegLoaded) return;

            isProcessing = true;
            generateButton.disabled = true;
            audioZipInput.disabled = true;
            imageInput.disabled = true;
            outputFormatSelect.disabled = true;

            progressContainer.classList.remove('hidden');
            logContainer.classList.remove('hidden');
            outputZipContainer.classList.add('hidden');
            logElement.textContent = '';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            progressText.textContent = 'Starting...';

            const outputVideoFormat = outputFormatSelect.value;
            const allGeneratedVideos = []; // To store { name: string, data: Uint8Array }

            try {
                // 1. Read the single image
                progressText.textContent = 'Reading image file...';
                const imageFile = imageInput.files[0];
                const imageExtension = getFileExtension(imageFile.name) || '.png'; // Default if no ext
                const imageFilenameInFS = `static_image${imageExtension}`;
                const imageData = await readFileAsUint8Array(imageFile);
                await ffmpegInstance.writeFile(imageFilenameInFS, imageData);
                logElement.textContent += `Image "${imageFile.name}" written to virtual FS as "${imageFilenameInFS}".\n`;

                // 2. Unzip audio files
                progressText.textContent = 'Extracting audio files from ZIP...';
                logElement.textContent += 'Reading audio ZIP...\n';
                const zipFile = audioZipInput.files[0];
                const jszip = new JSZip();
                const zip = await jszip.loadAsync(zipFile);
                
                const audioFileEntries = [];
                zip.forEach((relativePath, zipEntry) => {
                    // Basic audio file extension check - can be improved
                    const lowerRelativePath = relativePath.toLowerCase();
                    if (!zipEntry.dir && (lowerRelativePath.endsWith('.mp3') || lowerRelativePath.endsWith('.wav') || lowerRelativePath.endsWith('.m4a') || lowerRelativePath.endsWith('.aac') || lowerRelativePath.endsWith('.ogg') || lowerRelativePath.endsWith('.flac'))) {
                        audioFileEntries.push(zipEntry);
                    }
                });

                if (audioFileEntries.length === 0) {
                    throw new Error("No audio files found in the ZIP.");
                }
                logElement.textContent += `Found ${audioFileEntries.length} audio file(s) in ZIP.\n`;

                // 3. Process each audio file
                for (let i = 0; i < audioFileEntries.length; i++) {
                    const audioEntry = audioFileEntries[i];
                    const originalAudioFilename = audioEntry.name.split('/').pop(); // Get basename
                    const audioData = await audioEntry.async('uint8array');
                    
                    const currentProgress = ((i / audioFileEntries.length) * 100).toFixed(0);
                    progressBar.style.width = `${currentProgress}%`;
                    progressBar.textContent = `${currentProgress}%`;
                    progressText.textContent = `Processing video ${i + 1} of ${audioFileEntries.length}: ${originalAudioFilename}`;
                    logElement.textContent += `\n--- Processing: ${originalAudioFilename} ---\n`;

                    // Create a File object to get duration
                    const audioBlob = new Blob([audioData], { type: `audio/${getFileExtension(originalAudioFilename).substring(1) || 'mpeg'}` });
                    const audioFileForDuration = new File([audioBlob], originalAudioFilename, { type: audioBlob.type });
                    
                    let audioDuration;
                    try {
                        audioDuration = await getAudioDuration(audioFileForDuration);
                         logElement.textContent += `Audio duration: ${audioDuration.toFixed(2)} seconds.\n`;
                    } catch (durationError) {
                        logElement.textContent += `Error getting duration for ${originalAudioFilename}: ${durationError.message}. Skipping this audio.\n`;
                        console.error(`Duration error for ${originalAudioFilename}:`, durationError);
                        continue; // Skip this audio file
                    }

                    const audioFilenameInFS = `current_audio${getFileExtension(originalAudioFilename)}`;
                    await ffmpegInstance.writeFile(audioFilenameInFS, audioData);
                    logElement.textContent += `Audio "${originalAudioFilename}" written to virtual FS as "${audioFilenameInFS}".\n`;

                    const outputVideoFilenameBase = getFilenameWithoutExtension(originalAudioFilename);
                    const outputVideoFilenameInFS = `output_video.${outputVideoFormat}`;
                    
                    const command = [
                        '-loop', '1',
                        '-framerate', '1', // Input image framerate
                        '-i', imageFilenameInFS,
                        '-i', audioFilenameInFS,
                        '-vf', `fps=25,scale=trunc(iw/2)*2:trunc(ih/2)*2,format=yuv420p`, // Output 25fps, ensure even dimensions, yuv420p
                        '-c:v', 'libx264',
                        '-tune', 'stillimage',
                        '-preset', 'medium', // Balance between speed and quality
                        '-c:a', 'aac',
                        '-b:a', '128k',
                        '-t', audioDuration.toString(),
                        '-shortest',
                        '-movflags', '+faststart', // Good for web/streaming
                        outputVideoFilenameInFS
                    ];

                    logElement.textContent += `FFmpeg command: ffmpeg ${command.join(' ')}\n`;
                    await ffmpegInstance.exec(...command); // Spread arguments for exec

                    const videoOutputData = await ffmpegInstance.readFile(outputVideoFilenameInFS);
                    allGeneratedVideos.push({
                        name: `${outputVideoFilenameBase}.${outputVideoFormat}`,
                        data: videoOutputData
                    });
                    logElement.textContent += `Video for "${originalAudioFilename}" created successfully.\n`;

                    // Cleanup files for this iteration from FFmpeg FS
                    try { await ffmpegInstance.deleteFile(audioFilenameInFS); } catch(e) { console.warn("Could not delete audio from FS:", e); }
                    try { await ffmpegInstance.deleteFile(outputVideoFilenameInFS); } catch(e) { console.warn("Could not delete video from FS:", e); }
                }

                // Cleanup static image from FFmpeg FS
                try { await ffmpegInstance.deleteFile(imageFilenameInFS); } catch(e) { console.warn("Could not delete image from FS:", e); }

                if (allGeneratedVideos.length === 0) {
                    throw new Error("No videos were successfully generated. Check logs for errors.");
                }

                // 4. Zip all generated videos
                progressText.textContent = `Zipping ${allGeneratedVideos.length} video(s)...`;
                logElement.textContent += `\n--- Zipping ${allGeneratedVideos.length} video(s) ---\n`;
                const outputZip = new JSZip();
                for (const video of allGeneratedVideos) {
                    outputZip.file(video.name, video.data);
                    logElement.textContent += `Added ${video.name} to output ZIP.\n`;
                }

                const zipBlob = await outputZip.generateAsync({ type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } });
                const zipUrl = URL.createObjectURL(zipBlob);
                
                downloadZipLink.href = zipUrl;
                downloadZipLink.download = `generated_videos_${Date.now()}.zip`; // Unique filename
                outputZipContainer.classList.remove('hidden');
                logElement.textContent += `Output ZIP created successfully.\n`;
                progressText.textContent = `All ${allGeneratedVideos.length} videos processed and zipped!`;
                progressBar.style.width = '100%';
                progressBar.textContent = '100%';

            } catch (error) {
                console.error('Error during processing:', error);
                progressText.textContent = `Error: ${error.message}`;
                logElement.textContent += `\n\nERROR: ${error.message}\nStack: ${error.stack || 'N/A'}\n`;
                showMessage(`An error occurred: ${error.message}. Check the log for details.`);
            } finally {
                isProcessing = false;
                audioZipInput.disabled = false;
                imageInput.disabled = false;
                outputFormatSelect.disabled = false;
                updateGenerateButtonState();
            }
        }

        // --- Initial Setup ---
        window.addEventListener('load', () => {
            generateButton.textContent = 'Load FFmpeg & Generate';
            // Attempt to load FFmpeg on page load for faster startup
            loadFFmpeg().then(loaded => {
                if(loaded) updateGenerateButtonState();
            });
            audioZipInput.addEventListener('change', updateGenerateButtonState);
            imageInput.addEventListener('change', updateGenerateButtonState);
        });

        generateButton.addEventListener('click', generateAndZipVideos);

    </script>
</body>
</html>