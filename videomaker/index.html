<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single Image + Bulk Audio to Video Converter</title>
    <style>
        /* CSS styles remain exactly as provided in the original prompt */
        body {
            font-family: sans-serif;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px; /* Wider for multiple jobs */
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #555;
            text-align: center;
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px; /* Smaller margin */
            font-weight: bold;
        }
        input[type="file"], input[type="number"], select {
            display: block;
            width: 100%;
            padding: 8px; /* Smaller padding */
            margin-bottom: 10px; /* Smaller margin */
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.9em;
        }
        input[type="file"]::-webkit-file-upload-button {
            padding: 8px 12px; /* Smaller padding */
            border: none;
            background-color: #5cb85c;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-right: 10px;
        }
        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #4cae4c;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            margin-right: 10px; /* Margin between buttons */
            margin-bottom: 10px; /* Space below buttons */
        }
        button.primary {
            background-color: #007bff;
            color: white;
            width: auto; /* Allow natural width */
        }
        button.primary:hover {
            background-color: #0056b3;
        }
        button.secondary { /* No longer used for add job, but kept for potential future use */
            background-color: #6c757d;
            color: white;
            width: auto;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        #outputs-container { /* Renamed from jobs-container */
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }

        .output-slot { /* Renamed from job-slot */
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            background-color: #f9f9f9;
            position: relative;
        }
        .output-slot h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #444;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        /* Removed .job-controls as it's not directly applicable in the new structure */

        #overall-progress-container, #log-container { /* Removed #overall-output-container */
            margin-top: 25px;
            padding: 15px;
            border: 1px solid #eee;
            border-radius: 4px;
            background-color: #f0f0f0; /* Different background */
        }
        #overall-progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        #overallProgressBar {
            width: 0%;
            height: 20px;
            background-color: #4caf50;
            text-align: center;
            line-height: 20px;
            color: white;
            font-size: 12px;
            transition: width 0.2s ease-out;
        }
        #overall-progress-text {
            font-size: 0.9em;
            color: #666;
            text-align: center;
        }
        #log {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px; /* More space for logs */
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
            background-color: #fff;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .video-result { /* Renamed from .job-output */
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed #ccc;
        }
        .video-result video {
            display: block;
            max-width: 100%;
            max-height: 300px; /* Limit video preview height */
            margin-top: 10px;
            border-radius: 4px;
            background-color: #000; /* Black background for video player */
        }
        .video-result .status {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .video-result .status.success { color: #28a745; }
        .video-result .status.error { color: #dc3545; }
        .video-result .status.pending { color: #6c757d; }
        .video-result .status.processing { color: #007bff; }
        .video-result .message { font-size: 0.9em; color: #555; }

        a.download-link {
            display: inline-block;
            margin-top: 10px;
            padding: 8px 15px;
            background-color: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }
        a.download-link:hover {
            background-color: #218838;
        }
        .file-info { /* Kept for general file info display if needed */
            font-size: 0.8em;
            color: #777;
            margin-top: -5px;
            margin-bottom: 10px;
        }
        .input-group {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            background-color: #fdfdfd;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Single Image + Bulk Audio to Video Converter</h1>
        <p>Select a single image file and one or more audio files. A video will be generated for each audio file, using the selected image.</p>

        <div class="input-group">
            <h2>Inputs</h2>
            <div>
                <label for="imageFile">Select Single Image File:</label>
                <input type="file" id="imageFile" name="imageFile" accept="image/*">
                <div class="file-info">This image will be used for all videos.</div>
            </div>
            <div>
                <label for="audioFiles">Select Audio Files (Multiple):</label>
                <input type="file" id="audioFiles" name="audioFiles" multiple accept="audio/*">
                <div class="file-info">One video will be created per audio file.</div>
            </div>
            <div>
                <label for="outputFormat">Output Format:</label>
                <select id="outputFormat" name="outputFormat">
                    <option value="mp4">MP4</option>
                    <option value="mov">MOV</option>
                </select>
            </div>
        </div>

        <div>
            <button id="startAllButton" class="primary" disabled>Load FFmpeg & Start Processing</button>
        </div>

        <div id="outputs-container">
            </div>

        <div id="output-template" style="display: none;">
            <div class="output-slot" data-output-id="">
                <h3>Video for: <span></span></h3> <div class="video-result">
                    <div class="status">Status: Pending</div>
                    <div class="message"></div>
                    <video controls style="display: none;"></video>
                    <a class="download-link" style="display: none;" download="">Download Video</a>
                </div>
            </div>
        </div>

        <div id="overall-progress-container" style="display: none;">
            <h2>Overall Progress</h2>
            <div id="overall-progress-bar-container">
                <div id="overallProgressBar">0%</div>
            </div>
            <div id="overall-progress-text">Preparing...</div>
        </div>

        <div id="log-container" style="display: none;">
            <h2>FFmpeg Log (Current Video)</h2>
            <pre id="log"></pre>
        </div>

    </div>

    <script src="ffmpeg.min.js"></script>
    <script>
        const { FFmpeg } = FFmpegWASM;
        let ffmpegInstance = null;
        let processingTasks = []; // Array to hold tasks (one per audio file)
        let currentTaskIndex = -1;
        let isProcessing = false;

        // --- DOM Elements ---
        const imageFileInput = document.getElementById('imageFile');
        const audioFilesInput = document.getElementById('audioFiles');
        const outputFormatSelect = document.getElementById('outputFormat');
        const startAllButton = document.getElementById('startAllButton');
        const outputsContainer = document.getElementById('outputs-container');
        const outputTemplate = document.getElementById('output-template');

        const overallProgressBar = document.getElementById('overallProgressBar');
        const overallProgressText = document.getElementById('overall-progress-text');
        const logElement = document.getElementById('log');

        const overallProgressContainer = document.getElementById('overall-progress-container');
        const logContainer = document.getElementById('log-container');

        const FFMPEG_IMAGE_FILENAME = 'input_image'; // Generic name for the single image in FFmpeg FS
        const FFMPEG_AUDIO_FILENAME = 'input_audio'; // Generic name for current audio in FFmpeg FS

        // --- FFmpeg Loading ---
        async function loadFFmpeg() {
            if (ffmpegInstance) return true;

            startAllButton.textContent = 'Loading FFmpeg Core...';
            startAllButton.disabled = true;
            console.log('Creating FFmpeg instance...');

            try {
                ffmpegInstance = new FFmpeg();

                ffmpegInstance.on('log', ({ type, message }) => {
                    if (isProcessing) {
                        // console.log(`[FFmpeg Task ${currentTaskIndex + 1}] [${type}] ${message}`);
                        logElement.textContent += message + "\n";
                        logElement.scrollTop = logElement.scrollHeight;
                    }
                });

                ffmpegInstance.on('progress', ({ progress, time }) => {
                    // console.log(`FFmpeg progress (raw):`, { progress, time });
                    if (isProcessing && currentTaskIndex >= 0 && processingTasks[currentTaskIndex]) {
                        const taskProgress = Math.min(100, Math.max(0, (progress || 0) * 100));
                         const task = processingTasks[currentTaskIndex];
                        if (task && task.uiElements && task.uiElements.messageDiv) {
                             task.uiElements.messageDiv.textContent = `Generating video... (${taskProgress.toFixed(1)}%)`;
                        }
                        // Overall progress is handled per task completion
                    }
                });

                // Ensure these paths are correct relative to your HTML file
                await ffmpegInstance.load({
                    coreURL: './ffmpeg-core.js', 
                    wasmURL: './ffmpeg-core.wasm' 
                });

                console.log('FFmpeg core loaded successfully.');
                startAllButton.textContent = 'Start Processing';
                updateStartButtonState(); // Enable based on file selection
                return true;
            } catch (error) {
                console.error('Error loading FFmpeg:', error);
                startAllButton.textContent = 'Error Loading FFmpeg';
                startAllButton.disabled = true;
                displayModal(`Error loading FFmpeg: ${error.message || error}. Please check console, ensure ffmpeg-core.js and ffmpeg-core.wasm are in the same directory as this HTML file, and refresh.`);
                return false;
            }
        }

        // --- Input Change Listeners ---
        imageFileInput.addEventListener('change', updateStartButtonState);
        audioFilesInput.addEventListener('change', updateStartButtonState);


        function updateStartButtonState() {
            const imageSelected = imageFileInput.files.length > 0;
            const audioSelected = audioFilesInput.files.length > 0;
            startAllButton.disabled = !ffmpegInstance || !imageSelected || !audioSelected || isProcessing;
        }

        // --- File Reading Helper ---
        function readFileAsUint8Array(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = event => resolve(new Uint8Array(event.target.result));
                reader.onerror = error => reject(error);
                reader.readAsArrayBuffer(file);
            });
        }
        
        // --- Get Audio Duration (Optional, as -shortest is used, but good for info) ---
        function getAudioDuration(audioFile) {
            return new Promise((resolve, reject) => {
                if (!audioFile || !audioFile.type.startsWith('audio/')) {
                    return reject(new Error("Invalid or missing audio file for duration check."));
                }
                const tempAudio = document.createElement('audio');
                const objectURL = URL.createObjectURL(audioFile);
                tempAudio.preload = 'metadata';

                const cleanup = () => {
                    tempAudio.removeEventListener('loadedmetadata', onLoadedMetadata);
                    tempAudio.removeEventListener('error', onError);
                    URL.revokeObjectURL(objectURL);
                };
                const onLoadedMetadata = () => {
                    const duration = tempAudio.duration;
                    cleanup();
                    if (isNaN(duration) || !isFinite(duration) || duration <= 0) {
                       reject(new Error(`Could not determine valid duration for ${audioFile.name}.`));
                    } else {
                       resolve(duration);
                    }
                };
                const onError = (e) => {
                    cleanup();
                    reject(new Error(`Failed to load metadata for ${audioFile.name}.`));
                };
                tempAudio.addEventListener('loadedmetadata', onLoadedMetadata);
                tempAudio.addEventListener('error', onError);
                tempAudio.src = objectURL;
            });
        }


        // --- Main Processing Logic ---
        async function runAllConversions() {
            if (isProcessing) {
                console.warn("Processing already in progress.");
                return;
            }

            const loaded = await loadFFmpeg();
            if (!loaded) return;

            const imageFile = imageFileInput.files[0];
            const audioFiles = Array.from(audioFilesInput.files);

            if (!imageFile) {
                displayModal("Please select an image file.");
                return;
            }
            if (audioFiles.length === 0) {
                displayModal("Please select at least one audio file.");
                return;
            }

            isProcessing = true;
            startAllButton.disabled = true;
            imageFileInput.disabled = true;
            audioFilesInput.disabled = true;
            outputFormatSelect.disabled = true;

            overallProgressContainer.style.display = 'block';
            logContainer.style.display = 'block'; // Show log container from the start
            logElement.textContent = ''; // Clear log initially
            outputsContainer.innerHTML = ''; // Clear previous outputs
            processingTasks = []; // Reset tasks

            overallProgressBar.style.width = '0%';
            overallProgressBar.textContent = '0%';
            overallProgressText.textContent = 'Preparing tasks...';

            // Prepare UI slots and task data
            audioFiles.forEach((audioF, index) => {
                const outputId = `output_${index}_${Date.now()}`;
                const newOutputSlot = outputTemplate.firstElementChild.cloneNode(true);
                newOutputSlot.dataset.outputId = outputId;
                newOutputSlot.querySelector('h3 span').textContent = audioF.name;
                
                const uiElements = {
                    slot: newOutputSlot,
                    statusDiv: newOutputSlot.querySelector('.video-result .status'),
                    messageDiv: newOutputSlot.querySelector('.video-result .message'),
                    videoEl: newOutputSlot.querySelector('video'),
                    downloadEl: newOutputSlot.querySelector('a.download-link'),
                };
                updateOutputStatus(uiElements, 'Pending', 'Waiting in queue...');
                outputsContainer.appendChild(newOutputSlot);

                processingTasks.push({
                    id: outputId,
                    imageFile: imageFile, // The single image file object
                    audioFile: audioF,   // The current audio file object
                    outputFormat: outputFormatSelect.value,
                    uiElements: uiElements
                });
            });

            if (processingTasks.length === 0) {
                displayModal("No valid tasks to process.");
                resetUIState();
                return;
            }
            
            overallProgressText.textContent = `Found ${processingTasks.length} audio file(s) to process.`;

            // Write the single image to FFmpeg FS once
            let imageExtension = getFileExtension(imageFile.name) || '.png'; // Ensure extension
            const imageFsFilename = `${FFMPEG_IMAGE_FILENAME}${imageExtension}`;
            try {
                const imageData = await readFileAsUint8Array(imageFile);
                await ffmpegInstance.writeFile(imageFsFilename, imageData);
                console.log(`Image "${imageFile.name}" written to FFmpeg FS as "${imageFsFilename}"`);
            } catch (error) {
                console.error("Error writing image file to FFmpeg FS:", error);
                displayModal(`Failed to prepare image file: ${error.message}`);
                resetUIState();
                return;
            }


            // Process tasks sequentially
            for (let i = 0; i < processingTasks.length; i++) {
                currentTaskIndex = i;
                const task = processingTasks[i];

                const overallProgress = ((i) / processingTasks.length) * 100;
                overallProgressBar.style.width = `${overallProgress}%`;
                overallProgressBar.textContent = `${overallProgress.toFixed(0)}%`;
                overallProgressText.textContent = `Processing audio ${i + 1} of ${processingTasks.length}: ${task.audioFile.name}`;
                
                logElement.textContent += `\n--- Starting Video for: ${task.audioFile.name} ---\n`;
                updateOutputStatus(task.uiElements, 'Processing', 'Preparing audio...');

                await processSingleAudioToVideo(task, imageFsFilename); // Pass the FS image name
                
                // Clean up old video/download links if they exist from a previous run for this slot
                if (task.uiElements.videoEl.src && task.uiElements.videoEl.src.startsWith('blob:')) {
                    URL.revokeObjectURL(task.uiElements.videoEl.src);
                }
                if (task.uiElements.downloadEl.href && task.uiElements.downloadEl.href.startsWith('blob:')) {
                    URL.revokeObjectURL(task.uiElements.downloadEl.href);
                }
            }

            // Cleanup the single image from FFmpeg FS
            try {
                await ffmpegInstance.deleteFile(imageFsFilename);
                console.log(`Image "${imageFsFilename}" deleted from FFmpeg FS.`);
            } catch (e) {
                console.warn(`Could not delete image "${imageFsFilename}" from FFmpeg FS:`, e);
            }

            resetUIState(true); // true indicates processing finished
        }

        async function processSingleAudioToVideo(task, imageFsFilename) {
            const { audioFile, outputFormat, uiElements } = task;
            let audioExtension = getFileExtension(audioFile.name) || '.mp3';
            const audioFsFilename = `${FFMPEG_AUDIO_FILENAME}${audioExtension}`;
            const outputFilename = `video_for_${sanitizeFilename(audioFile.name)}.${outputFormat}`;

            try {
                // 1. Write current audio file to FFmpeg FS
                updateOutputStatus(uiElements, 'Processing', 'Uploading audio...');
                const audioData = await readFileAsUint8Array(audioFile);
                await ffmpegInstance.writeFile(audioFsFilename, audioData);
                console.log(`Audio "${audioFile.name}" written to FFmpeg FS as "${audioFsFilename}"`);
                updateOutputStatus(uiElements, 'Processing', 'Starting conversion...');


                // 2. Construct and Execute FFmpeg Command (MODIFIED PART)
                const command = [
                    '-loop', '1',                           // Loop the single image (CS1 specific)
                    '-i', imageFsFilename,                  // Input: the single image file
                    '-i', audioFsFilename,                  // Input: the current audio file
                    
                    // Video codec and quality parameters (inspired by Code Set 2)
                    '-c:v', 'libx264',                      
                    '-tune', 'stillimage',                  // Optimize for static image (CS1 specific, good to keep)
                    '-crf', '23',                           // Constant Rate Factor (from CS2)
                    '-preset', 'medium',                    // Encoding preset (from CS2)
                    
                    // Audio codec and quality parameters (inspired by Code Set 2)
                    '-c:a', 'aac',                          
                    '-b:a', '128k',                         // Audio bitrate (from CS2, was 192k in original CS1)
                    
                    // Video filter (common, ensure even dimensions & yuv420p for compatibility)
                    '-vf', 'scale=trunc(iw/2)*2:trunc(ih/2)*2,format=yuv420p', 
                    
                    // Output flags for web playback (from CS2)
                    '-movflags', '+faststart',              
                    
                    // Duration control (common, output duration matches shortest input - the audio)
                    '-shortest',                            
                    outputFilename                          // Output file
                ];

                console.log(`Executing FFmpeg for ${audioFile.name}: ffmpeg ${command.join(' ')}`);
                logElement.textContent += `FFmpeg command: ffmpeg ${command.join(' ')}\n`;
                await ffmpegInstance.exec(command);
                console.log(`FFmpeg execution finished for ${audioFile.name}.`);

                // 3. Read Output and Display
                updateOutputStatus(uiElements, 'Processing', 'Reading output video...');
                const outputData = await ffmpegInstance.readFile(outputFilename);
                console.log(`Output video for ${audioFile.name} read successfully (${(outputData.length / 1024 / 1024).toFixed(2)} MB).`);

                const mimeTypeMap = { 'mp4': 'video/mp4', 'mov': 'video/quicktime' };
                const mimeType = mimeTypeMap[outputFormat] || 'video/mp4';
                const videoBlob = new Blob([outputData.buffer], { type: mimeType });
                const videoUrl = URL.createObjectURL(videoBlob);

                uiElements.videoEl.src = videoUrl;
                uiElements.videoEl.style.display = 'block';
                uiElements.downloadEl.href = videoUrl;
                uiElements.downloadEl.download = outputFilename;
                uiElements.downloadEl.style.display = 'inline-block';

                updateOutputStatus(uiElements, 'Success', `Video created (${(outputData.length / 1024 / 1024).toFixed(2)} MB)`);
                return true;

            } catch (error) {
                console.error(`Error during conversion for ${audioFile.name}:`, error);
                updateOutputStatus(uiElements, 'Error', `Conversion failed: ${error.message || 'Unknown FFmpeg error'}`);
                uiElements.videoEl.style.display = 'none';
                uiElements.downloadEl.style.display = 'none';
                logElement.textContent += `ERROR for ${audioFile.name}: ${error.message || 'Unknown FFmpeg error'}\n`;
                return false;
            } finally {
                // 4. Cleanup current audio and output from FFmpeg FS for this task
                console.log(`Cleaning up FS for ${audioFile.name}...`);
                try {
                    await ffmpegInstance.deleteFile(audioFsFilename);
                } catch (e) { console.warn(`Could not delete ${audioFsFilename} from FS:`, e); }
                try {
                    await ffmpegInstance.deleteFile(outputFilename);
                } catch (e) { console.warn(`Could not delete ${outputFilename} from FS:`, e); }
                console.log(`FS cleanup attempt complete for ${audioFile.name}.`);
            }
        }

        function resetUIState(processingFinished = false) {
            isProcessing = false;
            currentTaskIndex = -1;
            imageFileInput.disabled = false;
            audioFilesInput.disabled = false;
            outputFormatSelect.disabled = false;
            
            if (processingFinished) {
                overallProgressBar.style.width = '100%';
                overallProgressBar.textContent = '100%';
                overallProgressText.textContent = `Processing Complete (${processingTasks.length} videos generated).`;
            } else { // E.g. error before starting loop
                 overallProgressContainer.style.display = 'none';
            }
            updateStartButtonState();
        }


        // --- UI Update Helpers ---
        function updateOutputStatus(uiElements, statusType, message) {
            if (uiElements && uiElements.statusDiv) {
                uiElements.statusDiv.textContent = `Status: ${statusType}`;
                uiElements.statusDiv.className = `status ${statusType.toLowerCase()}`;
            }
            if (uiElements && uiElements.messageDiv) {
                uiElements.messageDiv.textContent = message;
            }
        }

        function getFileExtension(filename) {
            const lastDot = filename.lastIndexOf('.');
            if (lastDot === -1) return '';
            return filename.substring(lastDot).toLowerCase();
        }

        function sanitizeFilename(filename) {
            // Remove extension before sanitizing, then re-add it if needed (or let ffmpeg handle output ext)
            const lastDot = filename.lastIndexOf('.');
            let namePart = filename;
            if (lastDot !== -1) {
                namePart = filename.substring(0, lastDot);
            }
            return namePart.replace(/[^a-z0-9._-]/gi, '_');
        }
        
        // Simple modal for alerts (replace window.alert)
        function displayModal(message) {
            // For a real app, use a proper modal library or implement a nicer one.
            // This is a very basic placeholder.
            console.info("MODAL:", message); // Log to console as a fallback
            
            // Remove any existing modal first
            const existingModal = document.getElementById('customModal');
            if (existingModal) {
                existingModal.remove();
            }

            const modal = document.createElement('div');
            modal.id = 'customModal'; // Added ID for easier removal
            modal.style.position = 'fixed';
            modal.style.left = '50%';
            modal.style.top = '20%';
            modal.style.transform = 'translateX(-50%)';
            modal.style.padding = '20px';
            modal.style.background = 'white';
            modal.style.border = '1px solid black';
            modal.style.borderRadius = '5px';
            modal.style.boxShadow = '0 0 10px rgba(0,0,0,0.5)';
            modal.style.zIndex = '1000';
            modal.style.textAlign = 'center'; // Center text
            modal.textContent = message;
            
            const closeButton = document.createElement('button');
            closeButton.textContent = 'Close';
            closeButton.style.marginTop = '15px';
            closeButton.style.padding = '8px 15px';
            closeButton.style.display = 'block';
            closeButton.style.margin = '15px auto 0 auto'; // Center button
            closeButton.onclick = () => modal.remove();
            
            modal.appendChild(closeButton);
            document.body.appendChild(modal);
        }


        // --- Initial Setup ---
        window.addEventListener('load', () => {
            startAllButton.textContent = 'Load FFmpeg & Start Processing';
            startAllButton.disabled = true; // Disabled until FFmpeg loads and files are selected
            // Attempt to load FFmpeg on page load for faster startup when user clicks Start
            loadFFmpeg().then(loaded => {
                if (loaded) updateStartButtonState();
            });
        });

        startAllButton.addEventListener('click', runAllConversions);

    </script>
</body>
</html>