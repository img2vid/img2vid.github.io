<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra-Fast Bulk Audio + Image to Video Converter (Web Workers - ImageBitmap & Main Thread Recording)</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            margin: 0; 
        }
        .container {
            max-width: 900px;
            margin: 20px auto; 
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        h1, h2, h3 { 
            color: #4a5568;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            font-size: 2.0em; /* Adjusted for longer title */
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .upload-section {
            display: grid;
            grid-template-columns: 1fr; 
            gap: 20px;
            margin-bottom: 30px;
        }
        @media (min-width: 640px) { 
            .upload-section {
                grid-template-columns: 1fr 1fr;
            }
        }
        .upload-box {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 30px 20px;
            text-align: center;
            background: linear-gradient(145deg, #f7fafc, #edf2f7);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .upload-box:hover {
            border-color: #667eea;
            background: linear-gradient(145deg, #edf2f7, #e2e8f0);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #667eea;
        }
        label { 
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #4a5568;
        }
        input[type="file"] {
            display: none;
        }
        .file-input-label { 
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-weight: 600;
        }
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }
        button {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 10px;
            position: relative;
            overflow: hidden;
        }
        button.primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        button.primary:hover:not(:disabled) { 
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(102, 126, 234, 0.4);
        }
        button.primary:disabled {
            background: #cbd5e0;
            color: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .settings-section {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        .settings-row {
            display: grid;
            grid-template-columns: 1fr; 
            gap: 20px;
            margin-bottom: 15px;
        }
        @media (min-width: 640px) { 
            .settings-row {
                grid-template-columns: 1fr 1fr;
            }
        }
        .setting-item label {
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .setting-item select, .setting-item input {
            padding: 8px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            background: white;
            width: 100%;
            box-sizing: border-box; 
        }
        .performance-info, .warning-box { 
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            font-weight: 600;
        }
        .performance-info {
            background: linear-gradient(45deg, #48bb78, #38a169);
        }
        .warning-box {
             background: linear-gradient(45deg, #f6ad55, #ed8936);
        }
        .file-info {
            font-size: 0.9em;
            color: #718096;
            margin-top: 10px;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        .progress-container {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            backdrop-filter: blur(5px);
            display: none; 
        }
        .progress-bar-container {
            width: 100%;
            height: 8px; 
            background: rgba(203, 213, 224, 0.5);
            border-radius: 20px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            border-radius: 20px;
            transition: width 0.3s ease-in-out; 
            position: relative;
        }
        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #4a5568;
            margin: 10px 0;
            min-height: 1.2em; 
        }
        .batch-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); 
            gap: 15px;
            margin-top: 20px;
        }
        .batch-item {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid #cbd5e0;
            transition: all 0.3s ease;
            font-size: 0.85em; 
        }
        .batch-item.processing {
            border-left-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }
        .batch-item.completed {
            border-left-color: #48bb78;
            background: rgba(72, 187, 120, 0.1);
        }
        .batch-item.error {
            border-left-color: #f56565;
            background: rgba(245, 101, 101, 0.1);
        }
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
            gap: 20px;
            margin-top: 30px;
        }
        .video-item {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .video-item:hover {
            transform: translateY(-5px);
        }
        .video-item video {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 15px;
            background-color: #000; 
        }
        .video-item h4 {
            margin: 0 0 10px 0;
            color: #4a5568;
            text-align: center;
            font-size: 1em; 
            word-break: break-all; 
        }
        .download-all-btn {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
            width: 100%;
            margin-top: 30px;
            font-size: 1.2em;
            padding: 20px;
            box-sizing: border-box; 
        }
        .download-all-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(72, 187, 120, 0.4);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .processing-indicator {
            display: inline-block;
            width: 10px; 
            height: 10px; 
            border-radius: 50%;
            background: #667eea;
            animation: pulse 1.5s infinite ease-in-out; 
            margin-right: 8px;
            vertical-align: middle; 
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° Ultra-Fast Bulk Audio + Image to Video Converter (Web Workers - ImageBitmap & Main Thread Recording)</h1>
        
        <div class="warning-box">
            ‚ö†Ô∏è Note: This demo uses browser-based processing (Web Workers, Canvas API & MediaRecorder) which has limitations. For production, server-side processing is recommended for performance and reliability, especially for long videos.
        </div>
        
        <div class="performance-info">
            üöÄ Using Web Workers for image rendering! Video/Audio combination on main thread.
        </div>
        
        <div class="upload-section">
            <div class="upload-box" onclick="document.getElementById('zipFile').click()">
                <div class="upload-icon">üì¶</div>
                <label for="zipFile">Select Audio Zip File:</label>
                <input type="file" id="zipFile" accept=".zip" />
                <div class="file-input-label">Choose Zip File</div>
                <div class="file-info" id="zipInfo" style="display: none;"></div>
            </div>
            
            <div class="upload-box" onclick="document.getElementById('imageFile').click()">
                <div class="upload-icon">üñºÔ∏è</div>
                <label for="imageFile">Select Image File:</label>
                <input type="file" id="imageFile" accept="image/*" />
                <div class="file-input-label">Choose Image</div>
                <div class="file-info" id="imageInfo" style="display: none;"></div>
            </div>
        </div>

        <div class="settings-section">
            <h3>‚öôÔ∏è Output Settings (Canvas API)</h3>
            <div class="settings-row">
                <div class="setting-item">
                    <label for="resolution">Video Resolution:</label>
                    <select id="resolution">
                        <option value="480p" selected>480p (Fastest)</option>
                        <option value="720p">720p (Balanced)</option>
                        <option value="1080p">1080p (Slower, Larger Files)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label for="maxWorkers">Max Concurrent Workers (for Image Rendering):</label>
                    <select id="maxWorkers">
                        <option value="1">1 (Sequential)</option>
                        <option value="2" selected>2</option>
                        <option value="4">4</option>
                        <option value="auto">Auto (CPU Cores)</option>
                    </select>
                </div>
            </div>
             <div class="warning-box" style="background: linear-gradient(45deg, #f687b3, #ed64a6); font-size: 0.9em; padding: 10px;">
                ‚ö†Ô∏è Note: Video and Audio are combined on the main thread after workers render the image frame. This can still be intensive for many/long files.
            </div>
        </div>

        <div style="text-align: center;">
            <button id="processBtn" class="primary" disabled>
                ‚ö° PROCESS & CREATE VIDEOS
            </button>
        </div>

        <div class="progress-container" id="progressContainer">
            <h3>Processing Progress</h3>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-text" id="progressText">Ready...</div>
            <div class="batch-status" id="batchStatus"></div>
        </div>

        <div class="video-grid" id="videoGrid"></div>

        <button id="downloadAllBtn" class="download-all-btn" style="display: none;">
            üì• Download All Videos as Zip
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <script id="videoWorkerSource" type="javascript/worker">
    // --- WEB WORKER SCRIPT ---
    self.onmessage = async function(event) {
        const { 
            actualDurationSeconds, 
            imageBitmapForWorker, 
            resolutionValue, 
            index, 
            audioFileName 
        } = event.data;
        // console.log(`[Worker ${index}] Received task for: ${audioFileName}, Duration: ${actualDurationSeconds}s`);

        async function renderFrameInWorker(imageBitmapToDraw, resolution, idx) {
            // console.log(`[Worker ${idx} renderFrame] Starting.`);
            let canvas; // No longer need MediaRecorder or tracks in worker
            try {
                canvas = new OffscreenCanvas(1, 1); 
                const ctx = canvas.getContext('2d', { alpha: false });

                switch(resolution) {
                    case '480p': canvas.width = 854; canvas.height = 480; break;
                    case '720p': canvas.width = 1280; canvas.height = 720; break;
                    case '1080p': canvas.width = 1920; canvas.height = 1080; break;
                    default: canvas.width = 854; canvas.height = 480;
                }
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const imgAspect = imageBitmapToDraw.width / imageBitmapToDraw.height;
                const canvasAspect = canvas.width / canvas.height;
                let drawWidth, drawHeight, drawX, drawY;

                if (imgAspect > canvasAspect) {
                    drawWidth = canvas.width;
                    drawHeight = drawWidth / imgAspect;
                    drawX = 0;
                    drawY = (canvas.height - drawHeight) / 2;
                } else {
                    drawHeight = canvas.height;
                    drawWidth = drawHeight * imgAspect;
                    drawX = (canvas.width - drawWidth) / 2;
                    drawY = 0;
                }
                ctx.drawImage(imageBitmapToDraw, drawX, drawY, drawWidth, drawHeight);
                // console.log(`[Worker ${idx} renderFrame] Image drawn to offscreen canvas.`);

                const renderedFrameBitmap = canvas.transferToImageBitmap();
                // console.log(`[Worker ${idx} renderFrame] Transferred OffscreenCanvas to ImageBitmap.`);
                return renderedFrameBitmap;

            } catch (error) {
                console.error(`[Worker ${idx} renderFrame] Error:`, error);
                throw error; 
            } finally {
                if (imageBitmapToDraw) { 
                    try { imageBitmapToDraw.close(); } catch(e) { /* console.warn(`[Worker ${idx}] Error closing received ImageBitmap:`, e); */ }
                }
            }
        }

        try {
            const renderedFrame = await renderFrameInWorker(imageBitmapForWorker, resolutionValue, index);
            self.postMessage({ 
                type: 'frameReady', 
                renderedFrameBitmap: renderedFrame, 
                actualDurationSeconds: actualDurationSeconds,
                index: index, 
                audioFileName: audioFileName 
            }, [renderedFrame]); 
        } catch (error) {
            self.postMessage({ type: 'error', error: { message: error.message, stack: error.stack }, index: index, audioFileName: audioFileName });
        }
    };
    </script>

    <script>
        // --- MAIN THREAD SCRIPT ---
        let processedVideos = []; 
        let audioFilesData = []; 
        let imageFileData = null; 
        let processingStartTime = null;
        let activeWorkersCount = 0; 
        
        const zipFileInput = document.getElementById('zipFile');
        const imageFileInput = document.getElementById('imageFile');
        const processBtn = document.getElementById('processBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const videoGrid = document.getElementById('videoGrid');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const zipInfo = document.getElementById('zipInfo');
        const imageInfo = document.getElementById('imageInfo');
        const batchStatusContainer = document.getElementById('batchStatus'); 
        const resolutionSelect = document.getElementById('resolution');
        const maxWorkersSelect = document.getElementById('maxWorkers');


        zipFileInput.addEventListener('change', handleZipUpload);
        imageFileInput.addEventListener('change', handleImageUpload);
        processBtn.addEventListener('click', processFiles);
        downloadAllBtn.addEventListener('click', downloadAllVideos);

        async function handleZipUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            zipInfo.textContent = 'Reading zip file...';
            zipInfo.style.display = 'block';
            processBtn.disabled = true; 
            try {
                const zip = new JSZip();
                const zipContent = await zip.loadAsync(file);
                audioFilesData = []; 
                let audioFileCount = 0;
                const filePromises = [];
                for (const [filename, zipEntry] of Object.entries(zipContent.files)) {
                    if (!zipEntry.dir && isAudioFile(filename)) {
                        filePromises.push(
                            zipEntry.async('blob').then(blob => {
                                audioFilesData.push({ name: filename, blob: blob, originalIndex: audioFileCount }); 
                                audioFileCount++;
                            }).catch(err => console.error(`Error processing ${filename} in zip:`, err))
                        );
                    }
                }
                await Promise.all(filePromises); 
                if (audioFileCount === 0) {
                    zipInfo.innerHTML = '<span style="color: #f56565;">‚ùå No audio files found in zip.</span>';
                } else {
                    zipInfo.innerHTML = `<strong>‚úÖ Found ${audioFileCount} audio files.</strong> Ready for processing!`;
                }
                updateProcessButton();
                console.log('Audio files loaded:', audioFilesData.length);
            } catch (error) {
                console.error('Error reading zip file:', error);
                zipInfo.innerHTML = `<span style="color: #f56565;">‚ùå Error reading zip: ${error.message}</span>`;
                updateProcessButton(); 
            }
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (!file.type.startsWith('image/')) {
                imageInfo.innerHTML = '<span style="color: #f56565;">‚ùå Please select a valid image file.</span>';
                imageInfo.style.display = 'block';
                imageFileData = null;
                updateProcessButton();
                return;
            }
            imageFileData = file;
            imageInfo.innerHTML = `<strong>‚úÖ ${file.name}</strong><br>Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`;
            imageInfo.style.display = 'block';
            updateProcessButton();
            console.log('Image file loaded:', file.name);
        }

        function updateProcessButton() {
            const hasAudio = audioFilesData && audioFilesData.length > 0;
            const hasImage = imageFileData !== null;
            processBtn.disabled = !hasAudio || !hasImage || activeWorkersCount > 0; 
            if (processBtn.disabled) {
                processBtn.style.opacity = '0.6'; 
                if (activeWorkersCount > 0) {
                    processBtn.textContent = `‚è≥ PROCESSING (${activeWorkersCount} TASKS)...`;
                } else if (!hasAudio && !hasImage) {
                    processBtn.textContent = 'üì¶ SELECT AUDIO & üñºÔ∏è IMAGE';
                } else if (!hasAudio) {
                    processBtn.textContent = 'üì¶ SELECT AUDIO ZIP FILE';
                } else if (!hasImage) {
                    processBtn.textContent = 'üñºÔ∏è SELECT IMAGE FILE';
                }
            } else {
                processBtn.style.opacity = '1';
                processBtn.textContent = '‚ö° PROCESS & CREATE VIDEOS';
            }
        }

        function isAudioFile(filename) {
            const audioExtensions = ['.mp3', '.wav', '.m4a', '.aac', '.ogg', '.flac', '.opus']; 
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return audioExtensions.includes(ext);
        }
        
        async function processFiles() {
            if (!audioFilesData.length || !imageFileData) {
                updateProgress(0, "Please select both audio files (in a zip) and an image file.", true);
                return;
            }
            processingStartTime = Date.now();
            activeWorkersCount = 0; 
            updateProcessButton(); 

            processedVideos = [];
            videoGrid.innerHTML = '';
            batchStatusContainer.innerHTML = '';
            progressContainer.style.display = 'block';
            updateProgress(0, 'Starting processing...', false);

            try {
                await processWithImageWorkersAndMainThreadAudio();
            } catch (error) {
                console.error('Critical processing error in main thread:', error);
                updateProgress(0, `Main Error: ${error.message}`, true);
            } finally {
                activeWorkersCount = 0; 
                updateProcessButton(); 
            }
        }

        async function processWithImageWorkersAndMainThreadAudio() {
            updateProgress(5, 'Preparing base image...', false);

            let optimizedImageBlob;
            try {
                optimizedImageBlob = await prepareOptimizedImage(imageFileData);
                if (!optimizedImageBlob || !(optimizedImageBlob instanceof Blob)) {
                    throw new Error("prepareOptimizedImage did not return a valid Blob.");
                }
            } catch (imgError) {
                console.error("[Main] Base image preparation failed:", imgError);
                updateProgress(0, `Base image preparation error: ${imgError.message}`, true);
                return; 
            }
            
            initializeBatchStatus(audioFilesData);
            
            let maxConcurrentWorkers;
            if (maxWorkersSelect.value === 'auto') {
                maxConcurrentWorkers = navigator.hardwareConcurrency || 2; 
            } else {
                maxConcurrentWorkers = parseInt(maxWorkersSelect.value, 10);
            }

            const workerScriptBlob = new Blob([document.getElementById('videoWorkerSource').textContent], { type: 'application/javascript' });
            const workerScriptUrl = URL.createObjectURL(workerScriptBlob);

            let filesProcessedCount = 0; 
            const totalFiles = audioFilesData.length;
            
            const allTasksPromises = [];
            const taskQueue = audioFilesData.map((fileEntry, idx) => ({ ...fileEntry, index: idx })); 
            let currentRunningWorkers = 0;
            
            const mainDecodingAudioContext = new AudioContext(); 

            const runWorkerTask = (task) => { 
                return new Promise(async (resolveWorkerTaskPromise) => {
                    currentRunningWorkers++;
                    activeWorkersCount++;
                    updateProcessButton();
                    updateBatchItemStatus(task.index, 'processing', task.name, 'Rendering frame...');

                    let actualDurationSeconds = 0;
                    
                    try {
                        const arrayBuffer = await task.blob.arrayBuffer(); 
                        const decodedAudioBuffer = await mainDecodingAudioContext.decodeAudioData(arrayBuffer);
                        actualDurationSeconds = decodedAudioBuffer.duration;

                        if (!isFinite(actualDurationSeconds) || actualDurationSeconds <= 0) {
                            throw new Error(`Invalid decoded audio duration for ${task.name}: ${actualDurationSeconds}`);
                        }
                    } catch (audioPrepError) {
                        console.error(`[Main] Error getting audio duration for ${task.name}:`, audioPrepError);
                        updateBatchItemStatus(task.index, 'error', task.name, `Audio duration error: ${audioPrepError.message}`);
                        currentRunningWorkers--;
                        activeWorkersCount--;
                        updateProcessButton();
                        resolveWorkerTaskPromise({ status: 'error', index: task.index, error: audioPrepError }); 
                        runNextWorkerTaskFromQueue();
                        return; 
                    }

                    const worker = new Worker(workerScriptUrl);
                    worker.onmessage = async (event) => {
                        const { type, renderedFrameBitmap, actualDurationSeconds: durationFromWorker, index: workerIndex, audioFileName, error } = event.data;
                        
                        if (type === 'frameReady') {
                            updateBatchItemStatus(workerIndex, 'processing', audioFileName, 'Combining audio/video...');
                            try {
                                const audioFileForCombine = audioFilesData.find(f => f.index === workerIndex || f.originalIndex === workerIndex);
                                if (!audioFileForCombine) throw new Error("Could not find original audio file for combining.");

                                const finalVideo = await combineAudioAndVideoOnMainThread(
                                    audioFileForCombine.blob, 
                                    renderedFrameBitmap, 
                                    durationFromWorker, 
                                    audioFileName.substring(0, audioFileName.lastIndexOf('.')) + '_final.webm',
                                    resolutionSelect.value 
                                );
                                if (finalVideo) {
                                    processedVideos.push(finalVideo);
                                    addVideoToGrid(finalVideo); 
                                    updateBatchItemStatus(workerIndex, 'completed', audioFileName, 'Combined successfully');
                                    resolveWorkerTaskPromise({ status: 'completed', index: workerIndex, video: finalVideo });
                                } else {
                                     updateBatchItemStatus(workerIndex, 'error', audioFileName, 'Combining failed');
                                     resolveWorkerTaskPromise({ status: 'error', index: workerIndex, error: new Error("Combining resulted in null") });
                                }
                            } catch (combineError) {
                                console.error(`[Main] Error combining for worker ${workerIndex} (${audioFileName}):`, combineError);
                                updateBatchItemStatus(workerIndex, 'error', audioFileName, `Combine error: ${combineError.message}`);
                                resolveWorkerTaskPromise({ status: 'error', index: workerIndex, error: combineError });
                            } 
                            // Note: renderedFrameBitmap is closed inside combineAudioAndVideoOnMainThread's finally block
                        } else if (type === 'error') {
                            console.error(`[Main] Error from Worker ${workerIndex} for ${audioFileName}:`, error.message);
                            updateBatchItemStatus(workerIndex, 'error', audioFileName, error.message || 'Unknown worker error');
                            resolveWorkerTaskPromise({ status: 'error', index: workerIndex, error: error });
                        }
                        
                        worker.terminate();
                        currentRunningWorkers--;
                        activeWorkersCount--;
                        filesProcessedCount++;
                        const overallProgress = 10 + (filesProcessedCount / totalFiles) * 85; 
                        updateProgress(overallProgress, `Processed ${filesProcessedCount}/${totalFiles}...`, type === 'error');
                        updateProcessButton();
                        runNextWorkerTaskFromQueue(); 
                    };

                    worker.onerror = (err) => {
                        console.error(`[Main] Worker ${task.index} (for ${task.name}) error event:`, err.message);
                        updateBatchItemStatus(task.index, 'error', task.name, `Worker error: ${err.message}`);
                        
                        worker.terminate();
                        currentRunningWorkers--;
                        activeWorkersCount--;
                        filesProcessedCount++;
                        const overallProgress = 10 + (filesProcessedCount / totalFiles) * 85;
                        updateProgress(overallProgress, `Worker error ${filesProcessedCount}/${totalFiles}...`, true);
                        updateProcessButton();
                        resolveWorkerTaskPromise({ status: 'error', index: task.index, error: err });
                        runNextWorkerTaskFromQueue();
                    };
                    
                    const freshImageBitmap = await createImageBitmap(optimizedImageBlob);

                    worker.postMessage({
                        actualDurationSeconds: actualDurationSeconds,
                        imageBitmapForWorker: freshImageBitmap, 
                        resolutionValue: resolutionSelect.value,
                        index: task.index,
                        audioFileName: task.name
                    }, [freshImageBitmap]); 
                });
            };

            const runNextWorkerTaskFromQueue = () => {
                if (taskQueue.length > 0 && currentRunningWorkers < maxConcurrentWorkers) {
                    const nextTask = taskQueue.shift();
                    if (nextTask) { 
                       allTasksPromises.push(runWorkerTask(nextTask));
                    }
                }
            };

            for (let k = 0; k < maxConcurrentWorkers && k < totalFiles; k++) {
                runNextWorkerTaskFromQueue();
            }
            
            await Promise.allSettled(allTasksPromises);

            if (mainDecodingAudioContext.state !== 'closed') {
                mainDecodingAudioContext.close();
            }
            URL.revokeObjectURL(workerScriptUrl);
            // optimizedImageBlob is used to create freshImageBitmaps, no direct URL to revoke here for it.
            // freshImageBitmaps are closed by workers or by combineAudioAndVideoOnMainThread.

            const totalTime = (Date.now() - processingStartTime) / 1000;
            updateProgress(100, `üéâ COMPLETE! Processed ${processedVideos.length}/${totalFiles} files in ${totalTime.toFixed(1)}s.`, false);
            
            if (processedVideos.length > 0) {
                downloadAllBtn.style.display = 'block';
                downloadAllBtn.disabled = false;
            }
            activeWorkersCount = 0; 
            updateProcessButton();
        }
        
        async function combineAudioAndVideoOnMainThread(audioBlob, renderedFrameBitmap, durationSeconds, outputName, resolutionValue) {
            return new Promise(async (resolve, reject) => {
                let mainAudioCtx = null;
                let mainAudioSource = null;
                let mainAudioDest = null;
                let mainCanvas = null;
                let mainRecorder = null;
                let animationFrameId = null;
                let videoTrackToStop = null;
                let audioTrackToStop = null;

                const cleanupMainCombineResources = () => {
                    cancelAnimationFrame(animationFrameId);
                    if (mainAudioCtx && mainAudioCtx.state !== 'closed') mainAudioCtx.close();
                    if (mainAudioSource) mainAudioSource.disconnect();
                    if (videoTrackToStop) videoTrackToStop.stop();
                    if (audioTrackToStop) audioTrackToStop.stop();
                    if (renderedFrameBitmap && !renderedFrameBitmap.closed) {
                        renderedFrameBitmap.close();
                    }
                };

                try {
                    mainAudioCtx = new AudioContext();
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const decodedAudioBuffer = await mainAudioCtx.decodeAudioData(arrayBuffer);
                    const actualAudioDuration = decodedAudioBuffer.duration; 

                    mainAudioSource = mainAudioCtx.createBufferSource();
                    mainAudioSource.buffer = decodedAudioBuffer;
                    mainAudioDest = mainAudioCtx.createMediaStreamDestination();
                    mainAudioSource.connect(mainAudioDest);
                    mainAudioSource.start(0);
                    audioTrackToStop = mainAudioDest.stream.getAudioTracks()[0];

                    mainCanvas = document.createElement('canvas');
                    const ctx = mainCanvas.getContext('2d');
                     switch(resolutionValue) {
                        case '480p': mainCanvas.width = 854; mainCanvas.height = 480; break;
                        case '720p': mainCanvas.width = 1280; mainCanvas.height = 720; break;
                        case '1080p': mainCanvas.width = 1920; mainCanvas.height = 1080; break;
                        default: mainCanvas.width = 854; mainCanvas.height = 480;
                    }
                    ctx.drawImage(renderedFrameBitmap, 0, 0, mainCanvas.width, mainCanvas.height);
                    
                    const frameRate = 10; 
                    const videoStream = mainCanvas.captureStream(frameRate);
                    videoTrackToStop = videoStream.getVideoTracks()[0];

                    if (!videoTrackToStop) throw new Error("Could not get video track from main canvas.");
                    if (!audioTrackToStop) throw new Error("Could not get audio track from audio blob.");

                    const mainCombinedStream = new MediaStream([videoTrackToStop, audioTrackToStop]);
                    mainRecorder = new MediaRecorder(mainCombinedStream, { mimeType: 'video/webm;codecs=vp8,opus' });
                    const chunks = [];

                    mainRecorder.ondataavailable = e => {
                        if (e.data.size > 0) chunks.push(e.data);
                    };

                    mainRecorder.onstop = () => {
                        const finalBlob = new Blob(chunks, { type: 'video/webm' });
                        resolve({ name: outputName, blob: finalBlob });
                        cleanupMainCombineResources(); 
                    };
                    
                    mainRecorder.onerror = (e) => {
                         console.error("[Main Combine] MediaRecorder error:", e);
                         reject(new Error("MediaRecorder error during final combination."));
                         cleanupMainCombineResources(); 
                    }

                    mainRecorder.start();
                    
                    function drawLoop() {
                        if (mainRecorder && mainRecorder.state === "recording") {
                            if (renderedFrameBitmap && !renderedFrameBitmap.closed) { 
                                ctx.drawImage(renderedFrameBitmap, 0, 0, mainCanvas.width, mainCanvas.height);
                            }
                            animationFrameId = requestAnimationFrame(drawLoop);
                        }
                    }
                    animationFrameId = requestAnimationFrame(drawLoop);

                    setTimeout(() => {
                        if (mainRecorder && mainRecorder.state === 'recording') {
                            mainRecorder.stop();
                        }
                    }, actualAudioDuration * 1000 + 500); 

                } catch (error) {
                    console.error("[Main Combine] Error in combineAudioAndVideoOnMainThread:", error);
                    reject(error);
                    cleanupMainCombineResources(); 
                }
                // No finally block here, cleanup is handled by onstop/onerror/catch
            });
        }
        
        async function prepareOptimizedImage(sourceImageFile) {
            return new Promise((resolve, reject) => {
                if (!sourceImageFile || typeof sourceImageFile.type === 'undefined' || !(sourceImageFile instanceof File)) {
                    const errorMsg = 'Invalid source image file provided for optimization.';
                    reject(new Error(errorMsg));
                    return;
                }
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                let objectUrl = null; 
                let loadTimeoutId = null;
                const cleanupAndReject = (errorMessage) => {
                    clearTimeout(loadTimeoutId);
                    if (objectUrl) {
                        URL.revokeObjectURL(objectUrl);
                        objectUrl = null; 
                    }
                    reject(new Error(errorMessage));
                };
                img.onload = () => {
                    clearTimeout(loadTimeoutId); 
                    const resValue = resolutionSelect.value;
                    let targetWidth, targetHeight;
                    switch(resValue) {
                        case '480p': targetWidth = 854; targetHeight = 480; break;
                        case '720p': targetWidth = 1280; targetHeight = 720; break;
                        case '1080p': targetWidth = 1920; targetHeight = 1080; break;
                        default: targetWidth = 854; targetHeight = 480;
                    }
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    ctx.fillStyle = '#000000'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    const imgAspect = img.width / img.height;
                    const canvasAspect = canvas.width / canvas.height;
                    let drawWidth, drawHeight, drawX, drawY;
                    if (imgAspect > canvasAspect) { 
                        drawWidth = canvas.width;
                        drawHeight = drawWidth / imgAspect;
                        drawX = 0;
                        drawY = (canvas.height - drawHeight) / 2;
                    } else { 
                        drawHeight = canvas.height;
                        drawWidth = drawHeight * imgAspect;
                        drawX = (canvas.width - drawWidth) / 2;
                        drawY = 0;
                    }
                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                    canvas.toBlob(blob => {
                        if (objectUrl) { 
                            URL.revokeObjectURL(objectUrl); 
                            objectUrl = null;
                        }
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Canvas toBlob failed to create image blob (returned null).'));
                        }
                    }, 'image/jpeg', 0.9); 
                };
                img.onerror = (errorEvent) => {
                    cleanupAndReject('Failed to load source image for optimization. Check console for image error.');
                };
                try {
                    objectUrl = URL.createObjectURL(sourceImageFile);
                    loadTimeoutId = setTimeout(() => {
                        const timeoutMsg = `Image loading timed out for ${sourceImageFile.name} after 20 seconds.`;
                        img.onload = null; 
                        img.onerror = null; 
                        img.src = ''; 
                        cleanupAndReject(timeoutMsg);
                    }, 20000);  
                    img.src = objectUrl;
                } catch (e) {
                    cleanupAndReject(`Failed to process source image: ${e.message}`);
                }
            });
        }

        function initializeBatchStatus(files) {
            batchStatusContainer.innerHTML = ''; 
            if (!files || files.length === 0) return;
            files.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'batch-item';
                item.id = `batch-item-${index}`; 
                item.innerHTML = `
                    <div style="font-weight: bold; font-size: 0.9em; word-break: break-all; margin-bottom: 5px;">${file.name || `File ${index+1}`}</div>
                    <div class="status-text" style="font-size: 0.8em;">Waiting...</div>
                `;
                batchStatusContainer.appendChild(item);
            });
        }

        function updateBatchItemStatus(index, status, filename = '', message = '') {
            console.log(`[updateBatchItemStatus] Index: ${index}, Status: ${status}, File: ${filename}, Msg: ${String(message)}`);
            const item = document.getElementById(`batch-item-${index}`);
            if (!item) {
                console.warn(`[updateBatchItemStatus] Item with id batch-item-${index} not found.`);
                return;
            }
            item.className = `batch-item ${status}`; 
            const statusTextElement = item.querySelector('.status-text');
            if (!statusTextElement) {
                 console.warn(`[updateBatchItemStatus] Status text element not found for item batch-item-${index}.`);
                return;
            }
            switch(status) {
                case 'processing':
                    statusTextElement.innerHTML = '<span class="processing-indicator"></span>Processing...';
                    break;
                case 'completed':
                    statusTextElement.innerHTML = '‚úÖ Complete';
                    break;
                case 'error':
                    statusTextElement.innerHTML = `‚ùå Error: ${String(message || 'Unknown issue')}`; 
                    break;
                default:
                    statusTextElement.textContent = 'Waiting...';
            }
        }

        function addVideoToGrid(video) {
            if (!video || !video.blob || !video.name) {
                console.error("[addVideoToGrid] Invalid video object provided:", video);
                return;
            }
            const videoItem = document.createElement('div');
            videoItem.className = 'video-item';
            const videoElement = document.createElement('video');
            videoElement.controls = true;
            videoElement.preload = 'metadata';
            let videoUrl = null;
            try {
                videoUrl = URL.createObjectURL(video.blob);
                videoElement.src = videoUrl;
            } catch (e) {
                console.error("[addVideoToGrid] Error creating object URL for video blob:", e, video.blob);
                videoItem.innerHTML = `<h4>${video.name}</h4><p style="color:red;">Error displaying video.</p>`;
                videoGrid.appendChild(videoItem);
                return;
            }
            const title = document.createElement('h4');
            title.textContent = video.name;
            const downloadLink = document.createElement('a');
            downloadLink.href = videoUrl; 
            downloadLink.download = video.name;
            downloadLink.textContent = 'Download Video';
            downloadLink.className = 'file-input-label'; 
            downloadLink.style.marginTop = '10px';
            downloadLink.style.fontSize = '0.9em';
            downloadLink.style.padding = '8px 16px';
            videoItem.appendChild(title);
            videoItem.appendChild(videoElement);
            videoItem.appendChild(downloadLink);
            videoGrid.appendChild(videoItem);
        }

        async function downloadAllVideos() {
            if (processedVideos.length === 0) {
                 updateProgress(0, "No videos to download.", true);
                 return;
            }
            updateProgress(0, 'Creating zip file (this may take a moment)...', false);
            downloadAllBtn.disabled = true;
            try {
                const zip = new JSZip();
                for (let i = 0; i < processedVideos.length; i++) {
                    const video = processedVideos[i];
                    if (!video || !video.blob || !video.name) {
                        continue;
                    }
                    const progress = (i / processedVideos.length) * 90;
                    updateProgress(progress, `Adding ${video.name} to zip...`, false);
                    zip.file(video.name, video.blob);
                    await new Promise(r => setTimeout(r, 10)); 
                }
                updateProgress(95, 'Generating zip file...', false);
                const zipBlob = await zip.generateAsync({ 
                    type: 'blob',
                    compression: 'STORE' 
                }, (metadata) => { 
                    updateProgress(95 + (metadata.percent * 0.05), `Zipping: ${metadata.percent.toFixed(0)}%`, false);
                });
                saveAs(zipBlob, `videos_batch_${Date.now()}.zip`);
                updateProgress(100, 'Zip download started!', false);
                setTimeout(() => {
                    updateProgress(0, 'Ready for next batch!', false);
                }, 3000);
            } catch (error) {
                console.error('Error creating zip:', error);
                updateProgress(0, `Error creating zip: ${error.message}`, true);
            } finally {
                downloadAllBtn.disabled = false;
            }
        }

        function updateProgress(percent, text, isError = false) {
            // console.log(`Progress: ${percent}% - ${text}`); 
            progressBar.style.width = percent + '%';
            progressText.textContent = text;
            if (isError) {
                progressText.style.color = '#f56565'; 
                progressBar.style.background = 'linear-gradient(45deg, #f56565, #c53030)'; 
            } else {
                progressText.style.color = '#4a5568'; 
                progressBar.style.background = 'linear-gradient(45deg, #667eea, #764ba2)'; 
            }
        }
        
        window.addEventListener('load', () => {
            updateProcessButton(); 
            if (navigator.hardwareConcurrency) {
                const autoOption = maxWorkersSelect.querySelector('option[value="auto"]');
                if (autoOption) autoOption.textContent = `Auto (${navigator.hardwareConcurrency} Cores)`;
            }
        });
    </script>
</body>
</html>