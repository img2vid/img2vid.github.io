<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra-Fast Bulk Audio + Image to Video Converter</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            margin: 0; /* Added to ensure full viewport height */
        }
        .container {
            max-width: 900px;
            margin: 20px auto; /* Adjusted margin for better centering */
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        h1, h2, h3 { /* Added h3 for consistency */
            color: #4a5568;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            font-size: 2.2em; /* Slightly adjusted for responsiveness */
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .upload-section {
            display: grid;
            grid-template-columns: 1fr; /* Default to 1 column for smaller screens */
            gap: 20px;
            margin-bottom: 30px;
        }
        @media (min-width: 640px) { /* Switch to 2 columns on larger screens */
            .upload-section {
                grid-template-columns: 1fr 1fr;
            }
        }
        .upload-box {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 30px 20px;
            text-align: center;
            background: linear-gradient(145deg, #f7fafc, #edf2f7);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .upload-box:hover {
            border-color: #667eea;
            background: linear-gradient(145deg, #edf2f7, #e2e8f0);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #667eea;
        }
        label { /* General label styling */
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #4a5568;
        }
        input[type="file"] {
            display: none;
        }
        .file-input-label { /* Specific label for file input button */
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-weight: 600;
        }
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }
        button {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 10px;
            position: relative;
            overflow: hidden;
        }
        button.primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        button.primary:hover:not(:disabled) { /* Ensure hover effect only when not disabled */
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(102, 126, 234, 0.4);
        }
        button.primary:disabled {
            background: #cbd5e0;
            color: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .settings-section {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        .settings-row {
            display: grid;
            grid-template-columns: 1fr; /* Default for smaller screens */
            gap: 20px;
            margin-bottom: 15px;
        }
        @media (min-width: 640px) { /* Switch to 2 columns on larger screens */
            .settings-row {
                grid-template-columns: 1fr 1fr;
            }
        }
        .setting-item label {
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .setting-item select, .setting-item input {
            padding: 8px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            background: white;
            width: 100%;
            box-sizing: border-box; /* Added for consistent sizing */
        }
        .performance-info, .warning-box { /* Combined for similar styling */
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            font-weight: 600;
        }
        .performance-info {
            background: linear-gradient(45deg, #48bb78, #38a169);
        }
        .warning-box {
             background: linear-gradient(45deg, #f6ad55, #ed8936);
        }
        .file-info {
            font-size: 0.9em;
            color: #718096;
            margin-top: 10px;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        .progress-container {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            backdrop-filter: blur(5px);
            display: none; /* Initially hidden */
        }
        .progress-bar-container {
            width: 100%;
            height: 8px; /* Reduced height for a slimmer look */
            background: rgba(203, 213, 224, 0.5);
            border-radius: 20px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            border-radius: 20px;
            transition: width 0.3s ease-in-out; /* Smoother transition */
            position: relative;
        }
        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #4a5568;
            margin: 10px 0;
            min-height: 1.2em; /* Ensure space for messages */
        }
        .batch-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Adjusted minmax */
            gap: 15px;
            margin-top: 20px;
        }
        .batch-item {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid #cbd5e0;
            transition: all 0.3s ease;
            font-size: 0.85em; /* Slightly smaller text */
        }
        .batch-item.processing {
            border-left-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }
        .batch-item.completed {
            border-left-color: #48bb78;
            background: rgba(72, 187, 120, 0.1);
        }
        .batch-item.error {
            border-left-color: #f56565;
            background: rgba(245, 101, 101, 0.1);
        }
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Adjusted minmax */
            gap: 20px;
            margin-top: 30px;
        }
        .video-item {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .video-item:hover {
            transform: translateY(-5px);
        }
        .video-item video {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 15px;
            background-color: #000; /* Added background for video player */
        }
        .video-item h4 {
            margin: 0 0 10px 0;
            color: #4a5568;
            text-align: center;
            font-size: 1em; /* Adjusted font size */
            word-break: break-all; /* Prevent long names from breaking layout */
        }
        .download-all-btn {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
            width: 100%;
            margin-top: 30px;
            font-size: 1.2em;
            padding: 20px;
            box-sizing: border-box; /* Ensure padding doesn't add to width */
        }
        .download-all-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(72, 187, 120, 0.4);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .processing-indicator {
            display: inline-block;
            width: 10px; /* Slightly smaller */
            height: 10px; /* Slightly smaller */
            border-radius: 50%;
            background: #667eea;
            animation: pulse 1.5s infinite ease-in-out; /* Smoother animation */
            margin-right: 8px;
            vertical-align: middle; /* Align with text */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° Ultra-Fast Bulk Audio + Image to Video Converter</h1>
        
        <div class="warning-box">
            ‚ö†Ô∏è Note: This demo uses browser-based processing (Canvas API & MediaRecorder) which has limitations. For production, server-side processing is recommended for performance and reliability, especially for long videos.
        </div>
        
        <div class="performance-info">
            üöÄ Using Canvas API for client-side video creation. Batch operations for efficiency!
        </div>
        
        <div class="upload-section">
            <div class="upload-box" onclick="document.getElementById('zipFile').click()">
                <div class="upload-icon">üì¶</div>
                <label for="zipFile">Select Audio Zip File:</label>
                <input type="file" id="zipFile" accept=".zip" />
                <div class="file-input-label">Choose Zip File</div>
                <div class="file-info" id="zipInfo" style="display: none;"></div>
            </div>
            
            <div class="upload-box" onclick="document.getElementById('imageFile').click()">
                <div class="upload-icon">üñºÔ∏è</div>
                <label for="imageFile">Select Image File:</label>
                <input type="file" id="imageFile" accept="image/*" />
                <div class="file-input-label">Choose Image</div>
                <div class="file-info" id="imageInfo" style="display: none;"></div>
            </div>
        </div>

        <div class="settings-section">
            <h3>‚öôÔ∏è Output Settings (Canvas API)</h3>
            <div class="settings-row">
                <div class="setting-item">
                    <label for="resolution">Video Resolution:</label>
                    <select id="resolution">
                        <option value="480p" selected>480p (Fastest)</option>
                        <option value="720p">720p (Balanced)</option>
                        <option value="1080p">1080p (Slower, Larger Files)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label for="batchSize">Batch Size (Sequential Processing):</label>
                    <select id="batchSize">
                        <option value="1" selected>1 file at once (Most Stable)</option>
                        <option value="2">2 files at once</option>
                        <option value="3">3 files at once</option>
                         <option value="5">5 files at once (May stress browser)</option>
                    </select>
                </div>
            </div>
             <div class="warning-box" style="background: linear-gradient(45deg, #f687b3, #ed64a6); font-size: 0.9em; padding: 10px;">
                ‚ö†Ô∏è Note: Quality settings like "preset" or "bitrate" are not applicable with the Canvas/MediaRecorder method, which uses browser defaults. Resolution affects output size.
            </div>
        </div>

        <div style="text-align: center;">
            <button id="processBtn" class="primary" disabled>
                ‚ö° PROCESS & CREATE VIDEOS
            </button>
        </div>

        <div class="progress-container" id="progressContainer">
            <h3>Processing Progress</h3>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-text" id="progressText">Ready...</div>
            <div class="batch-status" id="batchStatus"></div>
        </div>

        <div class="video-grid" id="videoGrid"></div>

        <button id="downloadAllBtn" class="download-all-btn" style="display: none;">
            üì• Download All Videos as Zip
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        // Global variables
        let processedVideos = [];
        let audioFilesData = []; 
        let imageFileData = null; 
        let processingStartTime = null;
        // const DEBUG_MAX_RECORDING_DURATION_MS = 10000; // Debug line removed/commented

        // DOM Elements
        const zipFileInput = document.getElementById('zipFile');
        const imageFileInput = document.getElementById('imageFile');
        const processBtn = document.getElementById('processBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const videoGrid = document.getElementById('videoGrid');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const zipInfo = document.getElementById('zipInfo');
        const imageInfo = document.getElementById('imageInfo');
        const batchStatusContainer = document.getElementById('batchStatus'); 

        // Settings Elements
        const batchSizeSelect = document.getElementById('batchSize');
        const resolutionSelect = document.getElementById('resolution');

        // Event Listeners
        zipFileInput.addEventListener('change', handleZipUpload);
        imageFileInput.addEventListener('change', handleImageUpload);
        processBtn.addEventListener('click', processFiles);
        downloadAllBtn.addEventListener('click', downloadAllVideos);

        // Function to handle Zip file upload
        async function handleZipUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            zipInfo.textContent = 'Reading zip file...';
            zipInfo.style.display = 'block';
            processBtn.disabled = true; 

            try {
                const zip = new JSZip();
                const zipContent = await zip.loadAsync(file);
                audioFilesData = []; 

                let audioFileCount = 0;
                const filePromises = [];

                for (const [filename, zipEntry] of Object.entries(zipContent.files)) {
                    if (!zipEntry.dir && isAudioFile(filename)) {
                        filePromises.push(
                            zipEntry.async('blob').then(blob => {
                                audioFilesData.push({
                                    name: filename,
                                    blob: blob,
                                });
                                audioFileCount++;
                            }).catch(err => {
                                console.error(`Error processing ${filename} in zip:`, err);
                            })
                        );
                    }
                }
                
                await Promise.all(filePromises); 

                if (audioFileCount === 0) {
                    zipInfo.innerHTML = '<span style="color: #f56565;">‚ùå No audio files found in zip.</span>';
                } else {
                    zipInfo.innerHTML = `<strong>‚úÖ Found ${audioFileCount} audio files.</strong> Ready for processing!`;
                }
                updateProcessButton();
                console.log('Audio files loaded:', audioFilesData.length);
            } catch (error) {
                console.error('Error reading zip file:', error);
                zipInfo.innerHTML = `<span style="color: #f56565;">‚ùå Error reading zip: ${error.message}</span>`;
                updateProcessButton(); 
            }
        }

        // Function to handle image file upload
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                imageInfo.innerHTML = '<span style="color: #f56565;">‚ùå Please select a valid image file.</span>';
                imageInfo.style.display = 'block';
                imageFileData = null;
                updateProcessButton();
                return;
            }

            imageFileData = file;
            imageInfo.innerHTML = `<strong>‚úÖ ${file.name}</strong><br>Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`;
            imageInfo.style.display = 'block';
            updateProcessButton();
            console.log('Image file loaded:', file.name);
        }

        // Function to update the state of the process button
        function updateProcessButton() {
            const hasAudio = audioFilesData && audioFilesData.length > 0;
            const hasImage = imageFileData !== null;
            
            processBtn.disabled = !hasAudio || !hasImage;
            
            if (processBtn.disabled) {
                processBtn.style.opacity = '0.6'; 
                 if (!hasAudio && !hasImage) {
                    processBtn.textContent = 'üì¶ SELECT AUDIO & üñºÔ∏è IMAGE';
                } else if (!hasAudio) {
                    processBtn.textContent = 'üì¶ SELECT AUDIO ZIP FILE';
                } else if (!hasImage) {
                    processBtn.textContent = 'üñºÔ∏è SELECT IMAGE FILE';
                }
            } else {
                processBtn.style.opacity = '1';
                processBtn.textContent = '‚ö° PROCESS & CREATE VIDEOS';
            }
        }

        // Function to check if a file is an audio file based on extension
        function isAudioFile(filename) {
            const audioExtensions = ['.mp3', '.wav', '.m4a', '.aac', '.ogg', '.flac', '.opus']; 
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return audioExtensions.includes(ext);
        }
        
        // Main function to process files
        async function processFiles() {
            if (!audioFilesData.length || !imageFileData) {
                updateProgress(0, "Please select both audio files (in a zip) and an image file.", true);
                return;
            }

            processingStartTime = Date.now();
            processBtn.disabled = true;
            downloadAllBtn.disabled = true; 
            downloadAllBtn.style.display = 'none';
            processedVideos = [];
            videoGrid.innerHTML = '';
            batchStatusContainer.innerHTML = '';
            progressContainer.style.display = 'block';

            updateProgress(0, 'Starting processing...', false);

            try {
                await processWithCanvasAPI();
            } catch (error) {
                console.error('Critical processing error:', error);
                updateProgress(0, `Error: ${error.message}`, true);
            } finally {
                 processBtn.disabled = false; 
                 updateProcessButton(); 
            }
        }

        // Function to process files using Canvas API
        async function processWithCanvasAPI() {
            updateProgress(5, 'Preparing image...', false);
            console.log('[processWithCanvasAPI] Starting image preparation.');

            let optimizedImageBlob;
            try {
                optimizedImageBlob = await prepareOptimizedImage(imageFileData);
                if (!optimizedImageBlob || !(optimizedImageBlob instanceof Blob)) { 
                    console.error("[processWithCanvasAPI] prepareOptimizedImage did not return a valid Blob.");
                    updateProgress(0, `Image preparation failed: Invalid blob returned.`, true);
                    return;
                }
                console.log('[processWithCanvasAPI] Image preparation successful. Blob size:', optimizedImageBlob.size, 'type:', optimizedImageBlob.type);
            } catch (imgError) {
                console.error("[processWithCanvasAPI] Image preparation failed with error:", imgError);
                updateProgress(0, `Image preparation error: ${imgError.message}`, true);
                return; 
            }
            
            let imageUrl;
            try {
                imageUrl = URL.createObjectURL(optimizedImageBlob);
                console.log('[processWithCanvasAPI] Created imageUrl:', imageUrl); 
            } catch (urlError) {
                console.error("[processWithCanvasAPI] Failed to create Object URL for image blob:", urlError);
                updateProgress(0, `Failed to create URL for image: ${urlError.message}`, true);
                return;
            }
            
            try {
                console.log('[processWithCanvasAPI] Calling initializeBatchStatus with audioFilesData count:', audioFilesData.length); 
                initializeBatchStatus(audioFilesData);
                console.log('[processWithCanvasAPI] initializeBatchStatus completed.'); 
            } catch (initBatchError) {
                console.error("[processWithCanvasAPI] Error during initializeBatchStatus:", initBatchError);
                updateProgress(0, `Error setting up batch display: ${initBatchError.message}`, true);
                URL.revokeObjectURL(imageUrl); 
                return;
            }
            
            console.log('[processWithCanvasAPI] Starting batch processing loop.'); 
            const batchSizeNum = parseInt(batchSizeSelect.value, 10);
            let completedCount = 0;
            
            for (let i = 0; i < audioFilesData.length; i += batchSizeNum) {
                const batch = audioFilesData.slice(i, i + batchSizeNum);
                console.log(`[processWithCanvasAPI] Processing batch starting at index ${i}, size ${batch.length}`); 
                
                const batchPromises = batch.map(async (audioFileEntry, indexInBatch) => {
                    const overallIndex = i + indexInBatch;
                    try {
                        updateBatchItemStatus(overallIndex, 'processing', audioFileEntry.name);
                        const video = await createVideoFromAudioAndImage(audioFileEntry, imageUrl, overallIndex);
                        
                        if (video) {
                            processedVideos.push(video);
                            addVideoToGrid(video);
                            updateBatchItemStatus(overallIndex, 'completed', audioFileEntry.name);
                        } else {
                            updateBatchItemStatus(overallIndex, 'error', audioFileEntry.name, 'Video creation failed (returned null)');
                        }
                    } catch (error) {
                        console.error(`Error processing ${audioFileEntry.name}:`, error);
                        updateBatchItemStatus(overallIndex, 'error', audioFileEntry.name, error.message);
                    } finally {
                        completedCount++;
                        const overallProgress = 10 + (completedCount / audioFilesData.length) * 85; 
                        updateProgress(overallProgress, `Processing file ${completedCount} of ${audioFilesData.length}...`, false);
                    }
                });
                await Promise.all(batchPromises); 
            }
            
            console.log('[processWithCanvasAPI] Batch processing loop completed.'); 
            const totalTime = (Date.now() - processingStartTime) / 1000;
            updateProgress(100, `üéâ COMPLETE! Processed ${processedVideos.length}/${audioFilesData.length} files in ${totalTime.toFixed(1)}s.`, false);
            
            if (processedVideos.length > 0) {
                downloadAllBtn.style.display = 'block';
                downloadAllBtn.disabled = false;
            }
            
            URL.revokeObjectURL(imageUrl); 
            console.log('[processWithCanvasAPI] Final image object URL revoked.'); 
        }

        // Function to create video from a single audio file and an image URL
        async function createVideoFromAudioAndImage(audioFileEntry, imageObjectUrl, index) {
            console.log(`[createVideo] Index ${index}: Starting for ${audioFileEntry.name}`);
            return new Promise(async (resolve) => {
                let audioCtx = null;
                let audioObjectUrl = null;
                let audio = null; 
                let mediaRecorder = null; 
                let recordingTimeoutId = null; 

                const cleanup = () => {
                    console.log(`[createVideo] Index ${index}: Cleaning up for ${audioFileEntry.name}`);
                    clearTimeout(recordingTimeoutId); 
                    if (audio && !audio.paused) audio.pause();
                    if (audioObjectUrl) {
                        URL.revokeObjectURL(audioObjectUrl);
                        audioObjectUrl = null;
                    }
                    if (audioCtx && audioCtx.state !== 'closed') {
                        audioCtx.close().catch(e => console.warn(`[createVideo] Index ${index}: Error closing AudioContext:`, e));
                        audioCtx = null;
                    }
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        console.log(`[createVideo] Index ${index}: MediaRecorder state is 'recording' during cleanup, attempting stop.`);
                        try { mediaRecorder.stop(); } catch(e) { console.warn(`[createVideo] Index ${index}: Error stopping MediaRecorder on cleanup:`, e); }
                    }
                    mediaRecorder = null; 
                };
                
                try {
                    audioObjectUrl = URL.createObjectURL(audioFileEntry.blob);
                    audio = new Audio(); 
                    audio.src = audioObjectUrl;
                    console.log(`[createVideo] Index ${index}: Audio object URL created: ${audioObjectUrl}`);
                    
                    let actualDurationSeconds;
                    try {
                        actualDurationSeconds = await new Promise((resolveLoad, rejectLoad) => {
                            const metadataTimeoutId = setTimeout(() => { 
                                console.error(`[createVideo] Index ${index}: Audio metadata loading timed out for ${audioFileEntry.name}`);
                                rejectLoad(new Error(`Audio metadata loading timed out for ${audioFileEntry.name}`));
                            }, 15000); 

                            audio.onloadedmetadata = () => {
                                clearTimeout(metadataTimeoutId);
                                console.log(`[createVideo] Index ${index}: Audio metadata loaded. Duration: ${audio.duration}s`);
                                resolveLoad(audio.duration);
                            };
                            audio.onerror = (e) => {
                                clearTimeout(metadataTimeoutId);
                                const errorMsg = `Audio loading error for ${audioFileEntry.name}. Browser reported: ${audio.error?.code} - ${audio.error?.message || 'Unknown audio error'}`;
                                console.error(`[createVideo] Index ${index}: ${errorMsg}`, e);
                                rejectLoad(new Error(errorMsg));
                            };
                            audio.load(); 
                        });
                    } catch (audioLoadError) {
                        console.error(`[createVideo] Index ${index}: Catching audio load error: ${audioLoadError.message}`);
                        cleanup();
                        resolve(null); 
                        return;
                    }

                    if (!isFinite(actualDurationSeconds) || actualDurationSeconds <= 0) {
                        const errMsg = `Invalid audio duration (${actualDurationSeconds}s) for ${audioFileEntry.name}`;
                        console.error(`[createVideo] Index ${index}: ${errMsg}`);
                        cleanup();
                        resolve(null); 
                        return;
                    }
                    
                    // Use actual duration from the audio file
                    const effectiveRecordingDurationMs = actualDurationSeconds * 1000;
                    console.log(`[createVideo] Index ${index}: Effective recording duration set to actual audio duration: ${effectiveRecordingDurationMs / 1000}s`);


                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d', { alpha: false }); 
                    
                    const resValue = resolutionSelect.value;
                    switch(resValue) {
                        case '480p': canvas.width = 854; canvas.height = 480; break;
                        case '720p': canvas.width = 1280; canvas.height = 720; break;
                        case '1080p': canvas.width = 1920; canvas.height = 1080; break;
                        default: canvas.width = 854; canvas.height = 480;
                    }
                    console.log(`[createVideo] Index ${index}: Canvas size ${canvas.width}x${canvas.height}`);
                    
                    const img = new Image();
                    img.onload = async () => {
                        console.log(`[createVideo] Index ${index}: Image loaded onto img element for canvas drawing.`);
                        try {
                            ctx.fillStyle = '#000000'; 
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            const imgAspect = img.width / img.height;
                            const canvasAspect = canvas.width / canvas.height;
                            let drawWidth, drawHeight, drawX, drawY;

                            if (imgAspect > canvasAspect) { 
                                drawWidth = canvas.width;
                                drawHeight = drawWidth / imgAspect;
                                drawX = 0;
                                drawY = (canvas.height - drawHeight) / 2;
                            } else { 
                                drawHeight = canvas.height;
                                drawWidth = drawHeight * imgAspect;
                                drawX = (canvas.width - drawWidth) / 2;
                                drawY = 0;
                            }
                            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                            console.log(`[createVideo] Index ${index}: Image drawn to canvas.`);
                            
                            const stream = canvas.captureStream(30); 
                            
                            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                            const source = audioCtx.createMediaElementSource(audio);
                            const dest = audioCtx.createMediaStreamDestination();
                            source.connect(dest);

                            if (dest.stream.getAudioTracks().length > 0) {
                                stream.addTrack(dest.stream.getAudioTracks()[0]);
                                console.log(`[createVideo] Index ${index}: Audio track added to stream.`);
                            } else {
                                console.warn(`[createVideo] Index ${index}: No audio track found for ${audioFileEntry.name}. Video will be silent.`);
                            }
                            
                            mediaRecorder = new MediaRecorder(stream, { 
                                mimeType: 'video/webm;codecs=vp8,opus' 
                            });
                            console.log(`[createVideo] Index ${index}: MediaRecorder created.`);
                            
                            const chunks = [];
                            mediaRecorder.ondataavailable = (e) => {
                                console.log(`[createVideo] Index ${index}: ondataavailable fired. Data size: ${e.data.size}`); 
                                if (e.data.size > 0) chunks.push(e.data);
                            };
                            
                            mediaRecorder.onstop = () => {
                                console.log(`[createVideo] Index ${index}: MediaRecorder stopped. Chunks length: ${chunks.length}`); 
                                if (chunks.length === 0) {
                                    console.warn(`[createVideo] Index ${index}: No data recorded for ${audioFileEntry.name}. Resolving null.`);
                                    cleanup();
                                    resolve(null);
                                    return;
                                }
                                const videoBlob = new Blob(chunks, { type: 'video/webm' });
                                const videoName = audioFileEntry.name.substring(0, audioFileEntry.name.lastIndexOf('.')) + '.webm';
                                console.log(`[createVideo] Index ${index}: Video blob created: ${videoName}, size: ${videoBlob.size}`);
                                cleanup();
                                resolve({ name: videoName, blob: videoBlob, originalAudio: audioFileEntry.name });
                            };

                            mediaRecorder.onerror = (e) => {
                                console.error(`[createVideo] Index ${index}: MediaRecorder error:`, e.error || e); 
                                updateBatchItemStatus(index, 'error', audioFileEntry.name, `MediaRecorder error: ${e.error?.name || 'Unknown'}`);
                                cleanup();
                                resolve(null);
                            };
                            
                            console.log(`[createVideo] Index ${index}: Attempting to start MediaRecorder.`);
                            mediaRecorder.start();
                            console.log(`[createVideo] Index ${index}: MediaRecorder started. State: ${mediaRecorder.state}`);
                            
                            console.log(`[createVideo] Index ${index}: Attempting to play audio.`);
                            audio.play()
                                .then(() => {
                                    console.log(`[createVideo] Index ${index}: Audio playback started successfully.`);
                                })
                                .catch(playError => { 
                                    console.error(`[createVideo] Index ${index}: Audio play error for ${audioFileEntry.name}:`, playError);
                                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                                        console.log(`[createVideo] Index ${index}: Stopping MediaRecorder due to audio play error.`);
                                        try { mediaRecorder.stop(); } catch(e) { /* ignore */ }
                                    } else { 
                                        console.log(`[createVideo] Index ${index}: MediaRecorder not recording or already stopped. Cleaning up due to audio play error.`);
                                        cleanup();
                                        resolve(null);
                                    }
                                });
                            
                            recordingTimeoutId = setTimeout(() => { 
                                console.log(`[createVideo] Index ${index}: Timeout to stop MediaRecorder. Current state: ${mediaRecorder?.state}`);
                                if (mediaRecorder && mediaRecorder.state === 'recording') {
                                    mediaRecorder.stop();
                                }
                                if (audio && !audio.paused) audio.pause(); 
                            }, effectiveRecordingDurationMs + 500); // Use effective duration, add buffer
                        } catch(innerError) {
                            console.error(`[createVideo] Index ${index}: Error during image load/recording:`, innerError);
                            updateBatchItemStatus(index, 'error', audioFileEntry.name, innerError.message);
                            cleanup();
                            resolve(null);
                        }
                    };
                    img.onerror = (imgErrorEvent) => {
                        console.error(`[createVideo] Index ${index}: Image could not be loaded for video creation. image.src was ${img.src}`, imgErrorEvent);
                        updateBatchItemStatus(index, 'error', audioFileEntry.name, 'Image load failed for video frame.');
                        cleanup();
                        resolve(null);
                    };
                    img.src = imageObjectUrl; 
                    console.log(`[createVideo] Index ${index}: img.src set to processed image URL: ${imageObjectUrl}`);
                    
                } catch (error) {
                    console.error(`[createVideo] Index ${index}: Outer error creating video for ${audioFileEntry.name}:`, error);
                    updateBatchItemStatus(index, 'error', audioFileEntry.name, error.message);
                    cleanup();
                    resolve(null);
                } 
            });
        }
        
        // Function to prepare an optimized image (resized to fit video dimensions)
        async function prepareOptimizedImage(sourceImageFile) {
            console.log('[prepareOptimizedImage] Started.'); 
            return new Promise((resolve, reject) => {
                if (!sourceImageFile || typeof sourceImageFile.type === 'undefined' || !(sourceImageFile instanceof File)) {
                    const errorMsg = 'Invalid source image file provided for optimization.';
                    console.error('[prepareOptimizedImage]', errorMsg, 'Received:', sourceImageFile);
                    reject(new Error(errorMsg));
                    return;
                }

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                let objectUrl = null; 
                let loadTimeoutId = null;

                const cleanupAndReject = (errorMessage) => {
                    console.error('[prepareOptimizedImage] CleanupAndReject called with:', errorMessage);
                    clearTimeout(loadTimeoutId);
                    if (objectUrl) {
                        console.log('[prepareOptimizedImage] Revoking objectUrl in cleanupAndReject:', objectUrl);
                        URL.revokeObjectURL(objectUrl);
                        objectUrl = null; 
                    }
                    reject(new Error(errorMessage));
                };

                console.log('[prepareOptimizedImage] Image element created.'); 

                img.onload = () => {
                    clearTimeout(loadTimeoutId); 
                    console.log('[prepareOptimizedImage] img.onload triggered.'); 
                    
                    const resValue = resolutionSelect.value;
                    let targetWidth, targetHeight;
                    switch(resValue) {
                        case '480p': targetWidth = 854; targetHeight = 480; break;
                        case '720p': targetWidth = 1280; targetHeight = 720; break;
                        case '1080p': targetWidth = 1920; targetHeight = 1080; break;
                        default: targetWidth = 854; targetHeight = 480;
                    }
                    
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    console.log(`[prepareOptimizedImage] Canvas dimensions set to: ${canvas.width}x${canvas.height}`); 
                    
                    ctx.fillStyle = '#000000'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    const imgAspect = img.width / img.height;
                    const canvasAspect = canvas.width / canvas.height;
                    let drawWidth, drawHeight, drawX, drawY;

                    if (imgAspect > canvasAspect) { 
                        drawWidth = canvas.width;
                        drawHeight = drawWidth / imgAspect;
                        drawX = 0;
                        drawY = (canvas.height - drawHeight) / 2;
                    } else { 
                        drawHeight = canvas.height;
                        drawWidth = drawHeight * imgAspect;
                        drawX = (canvas.width - drawWidth) / 2;
                        drawY = 0;
                    }
                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                    console.log('[prepareOptimizedImage] Image drawn to canvas.'); 
                    
                    console.log('[prepareOptimizedImage] Calling canvas.toBlob...'); 
                    canvas.toBlob(blob => {
                        if (objectUrl) { 
                            console.log('[prepareOptimizedImage] Revoking objectUrl in toBlob callback:', objectUrl);
                            URL.revokeObjectURL(objectUrl); 
                            objectUrl = null;
                        }
                        if (blob) {
                            console.log('[prepareOptimizedImage] canvas.toBlob succeeded. Blob size:', blob.size); 
                            resolve(blob);
                        } else {
                            console.error('[prepareOptimizedImage] canvas.toBlob failed (returned null).'); 
                            reject(new Error('Canvas toBlob failed to create image blob (returned null).'));
                        }
                    }, 'image/jpeg', 0.9); 
                };
                
                img.onerror = (errorEvent) => {
                    console.error('[prepareOptimizedImage] img.onerror triggered. Image src was:', img.src, 'Error event:', errorEvent); 
                    cleanupAndReject('Failed to load source image for optimization. Check console for image error.');
                };
                
                try {
                    console.log('[prepareOptimizedImage] Creating object URL for image file:', sourceImageFile.name, sourceImageFile.type); 
                    objectUrl = URL.createObjectURL(sourceImageFile);
                    console.log('[prepareOptimizedImage] Object URL created:', objectUrl); 
                    
                    loadTimeoutId = setTimeout(() => {
                        const timeoutMsg = `Image loading timed out for ${sourceImageFile.name} after 20 seconds. Current img.src: ${img.src}`;
                        console.error(`[prepareOptimizedImage] ${timeoutMsg}`);
                        img.onload = null; 
                        img.onerror = null; 
                        img.src = ''; 
                        cleanupAndReject(timeoutMsg);
                    }, 20000);  

                    img.src = objectUrl;
                    console.log('[prepareOptimizedImage] img.src set to:', objectUrl); 
                } catch (e) {
                    console.error('[prepareOptimizedImage] Error in try block (createObjectURL or src set):', e); 
                    cleanupAndReject(`Failed to process source image: ${e.message}`);
                }
            });
        }

        // Function to initialize batch status display
        function initializeBatchStatus(files) {
            batchStatusContainer.innerHTML = ''; 
            if (!files || files.length === 0) {
                console.warn("[initializeBatchStatus] No files to initialize status for.");
                return;
            }
            files.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'batch-item';
                item.id = `batch-item-${index}`;
                item.innerHTML = `
                    <div style="font-weight: bold; font-size: 0.9em; word-break: break-all; margin-bottom: 5px;">${file.name || `File ${index+1}`}</div>
                    <div class="status-text" style="font-size: 0.8em;">Waiting...</div>
                `;
                batchStatusContainer.appendChild(item);
            });
        }

        // Function to update status of a batch item
        function updateBatchItemStatus(index, status, filename = '', message = '') {
            const item = document.getElementById(`batch-item-${index}`);
            if (!item) {
                console.warn(`[updateBatchItemStatus] Item with id batch-item-${index} not found.`);
                return;
            }
            
            item.className = `batch-item ${status}`; 
            const statusTextElement = item.querySelector('.status-text');
            if (!statusTextElement) {
                console.warn(`[updateBatchItemStatus] Status text element not found for item batch-item-${index}.`);
                return;
            }

            switch(status) {
                case 'processing':
                    statusTextElement.innerHTML = '<span class="processing-indicator"></span>Processing...';
                    break;
                case 'completed':
                    statusTextElement.innerHTML = '‚úÖ Complete';
                    break;
                case 'error':
                    statusTextElement.innerHTML = `‚ùå Error: ${message || 'Unknown issue'}`;
                    break;
                default:
                    statusTextElement.textContent = 'Waiting...';
            }
        }

        // Function to add a processed video to the grid
        function addVideoToGrid(video) {
            if (!video || !video.blob || !video.name) {
                console.error("[addVideoToGrid] Invalid video object provided:", video);
                return;
            }
            const videoItem = document.createElement('div');
            videoItem.className = 'video-item';
            
            const videoElement = document.createElement('video');
            videoElement.controls = true;
            videoElement.preload = 'metadata';
            let videoUrl = null;
            try {
                videoUrl = URL.createObjectURL(video.blob);
                videoElement.src = videoUrl;
            } catch (e) {
                console.error("[addVideoToGrid] Error creating object URL for video blob:", e, video.blob);
                videoItem.innerHTML = `<h4>${video.name}</h4><p style="color:red;">Error displaying video.</p>`;
                videoGrid.appendChild(videoItem);
                return;
            }
            
            const title = document.createElement('h4');
            title.textContent = video.name;
            
            const downloadLink = document.createElement('a');
            downloadLink.href = videoUrl; 
            downloadLink.download = video.name;
            downloadLink.textContent = 'Download Video';
            downloadLink.className = 'file-input-label'; 
            downloadLink.style.marginTop = '10px';
            downloadLink.style.fontSize = '0.9em';
            downloadLink.style.padding = '8px 16px';


            videoItem.appendChild(title);
            videoItem.appendChild(videoElement);
            videoItem.appendChild(downloadLink);
            
            videoGrid.appendChild(videoItem);
        }

        // Function to download all processed videos as a zip
        async function downloadAllVideos() {
            if (processedVideos.length === 0) {
                 updateProgress(0, "No videos to download.", true);
                 return;
            }

            updateProgress(0, 'Creating zip file (this may take a moment)...', false);
            downloadAllBtn.disabled = true;

            try {
                const zip = new JSZip();
                
                for (let i = 0; i < processedVideos.length; i++) {
                    const video = processedVideos[i];
                    if (!video || !video.blob || !video.name) {
                        console.warn("[downloadAllVideos] Skipping invalid video object in processedVideos array at index:", i, video);
                        continue;
                    }
                    const progress = (i / processedVideos.length) * 90;
                    updateProgress(progress, `Adding ${video.name} to zip...`, false);
                    zip.file(video.name, video.blob);
                    await new Promise(r => setTimeout(r, 10)); 
                }

                updateProgress(95, 'Generating zip file...', false);
                const zipBlob = await zip.generateAsync({ 
                    type: 'blob',
                    compression: 'STORE' 
                }, (metadata) => { 
                    updateProgress(95 + (metadata.percent * 0.05), `Zipping: ${metadata.percent.toFixed(0)}%`, false);
                });
                
                saveAs(zipBlob, `videos_batch_${Date.now()}.zip`);
                updateProgress(100, 'Zip download started!', false);
                
                setTimeout(() => {
                    updateProgress(0, 'Ready for next batch!', false);
                }, 3000);

            } catch (error) {
                console.error('Error creating zip:', error);
                updateProgress(0, `Error creating zip: ${error.message}`, true);
            } finally {
                downloadAllBtn.disabled = false;
            }
        }

        // Function to update progress bar and text
        function updateProgress(percent, text, isError = false) {
            console.log(`Progress: ${percent}% - ${text}`); 
            progressBar.style.width = percent + '%';
            progressText.textContent = text;
            if (isError) {
                progressText.style.color = '#f56565'; 
                progressBar.style.background = 'linear-gradient(45deg, #f56565, #c53030)'; 
            } else {
                progressText.style.color = '#4a5568'; 
                progressBar.style.background = 'linear-gradient(45deg, #667eea, #764ba2)'; 
            }
        }
        
        // Initialize on window load
        window.addEventListener('load', () => {
            updateProcessButton(); 
        });
    </script>
</body>
</html>