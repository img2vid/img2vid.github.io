<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulk Audio + Image to Video Converter</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        h1, h2 {
            color: #4a5568;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .upload-box {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 30px 20px;
            text-align: center;
            background: linear-gradient(145deg, #f7fafc, #edf2f7);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .upload-box:hover {
            border-color: #667eea;
            background: linear-gradient(145deg, #edf2f7, #e2e8f0);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .upload-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s ease;
        }
        .upload-box:hover::before {
            left: 100%;
        }
        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #667eea;
        }
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #4a5568;
        }
        input[type="file"] {
            display: none;
        }
        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }
        button {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            margin: 10px;
            position: relative;
            overflow: hidden;
        }
        button.primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        button.primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(102, 126, 234, 0.4);
        }
        button.primary:disabled {
            background: #cbd5e0;
            color: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .file-info {
            font-size: 0.9em;
            color: #718096;
            margin-top: 10px;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        .progress-container {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            backdrop-filter: blur(5px);
            display: none;
        }
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(203, 213, 224, 0.5);
            border-radius: 20px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            border-radius: 20px;
            transition: width 0.3s ease;
            position: relative;
        }
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #4a5568;
            margin: 10px 0;
        }
        .log-container {
            margin-top: 20px;
            background: #1a202c;
            color: #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        .video-item {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .video-item:hover {
            transform: translateY(-5px);
        }
        .video-item video {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .video-item h4 {
            margin: 0 0 10px 0;
            color: #4a5568;
            text-align: center;
        }
        .download-all-btn {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
            width: 100%;
            margin-top: 30px;
            font-size: 1.2em;
            padding: 20px;
        }
        .download-all-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(72, 187, 120, 0.4);
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-pending { background: #cbd5e0; }
        .status-processing { background: #667eea; animation: pulse 1.5s infinite; }
        .status-success { background: #48bb78; }
        .status-error { background: #f56565; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ Bulk Audio + Image to Video Converter</h1>
        <p style="text-align: center; font-size: 1.1em; color: #718096; margin-bottom: 30px;">
            Upload a zip file containing audio files and one image to create videos for each audio file.
        </p>
        
        <div class="upload-section">
            <div class="upload-box" onclick="document.getElementById('zipFile').click()">
                <div class="upload-icon">üì¶</div>
                <label for="zipFile">Select Audio Zip File:</label>
                <input type="file" id="zipFile" accept=".zip" />
                <div class="file-input-label">Choose Zip File</div>
                <div class="file-info" id="zipInfo" style="display: none;"></div>
            </div>
            
            <div class="upload-box" onclick="document.getElementById('imageFile').click()">
                <div class="upload-icon">üñºÔ∏è</div>
                <label for="imageFile">Select Image File:</label>
                <input type="file" id="imageFile" accept="image/*" />
                <div class="file-input-label">Choose Image</div>
                <div class="file-info" id="imageInfo" style="display: none;"></div>
            </div>
        </div>

        <div style="text-align: center;">
            <button id="processBtn" class="primary" disabled>
                üöÄ Process Files & Create Videos
            </button>
        </div>

        <div class="progress-container" id="progressContainer">
            <h3>Processing Progress</h3>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-text" id="progressText">Initializing...</div>
        </div>

        <div class="log-container" id="logContainer">
            <pre id="logOutput"></pre>
        </div>

        <div class="video-grid" id="videoGrid"></div>

        <button id="downloadAllBtn" class="download-all-btn" style="display: none;">
            üì• Download All Videos as Zip
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="ffmpeg.min.js"></script>
    <script>
        const { FFmpeg } = FFmpegWASM;
        let ffmpegInstance = null;
        let processedVideos = [];
        let audioFiles = [];
        let imageFile = null;

        // DOM Elements
        const zipFileInput = document.getElementById('zipFile');
        const imageFileInput = document.getElementById('imageFile');
        const processBtn = document.getElementById('processBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const logContainer = document.getElementById('logContainer');
        const logOutput = document.getElementById('logOutput');
        const videoGrid = document.getElementById('videoGrid');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const zipInfo = document.getElementById('zipInfo');
        const imageInfo = document.getElementById('imageInfo');

        // Event Listeners
        zipFileInput.addEventListener('change', handleZipUpload);
        imageFileInput.addEventListener('change', handleImageUpload);
        processBtn.addEventListener('click', processFiles);
        downloadAllBtn.addEventListener('click', downloadAllVideos);

        async function handleZipUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const zip = new JSZip();
                const zipContent = await zip.loadAsync(file);
                audioFiles = [];

                for (const [filename, zipEntry] of Object.entries(zipContent.files)) {
                    if (!zipEntry.dir && isAudioFile(filename)) {
                        const blob = await zipEntry.async('blob');
                        audioFiles.push({
                            name: filename,
                            blob: blob
                        });
                    }
                }

                zipInfo.textContent = `Found ${audioFiles.length} audio files in zip`;
                zipInfo.style.display = 'block';
                updateProcessButton();
            } catch (error) {
                console.error('Error reading zip file:', error);
                zipInfo.textContent = 'Error reading zip file';
                zipInfo.style.display = 'block';
            }
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            imageFile = file;
            imageInfo.textContent = `Selected: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
            imageInfo.style.display = 'block';
            updateProcessButton();
        }

        function updateProcessButton() {
            processBtn.disabled = !audioFiles.length || !imageFile;
        }

        function isAudioFile(filename) {
            const audioExtensions = ['.mp3', '.wav', '.m4a', '.aac', '.ogg', '.flac', '.wma'];
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return audioExtensions.includes(ext);
        }

        async function loadFFmpeg() {
            if (ffmpegInstance) return true;

            try {
                ffmpegInstance = new FFmpeg();

                ffmpegInstance.on('log', ({ type, message }) => {
                    console.log(`[FFmpeg] [${type}] ${message}`);
                    logOutput.textContent += message + "\n";
                    logOutput.scrollTop = logOutput.scrollHeight;
                    logContainer.style.display = 'block';
                });

                ffmpegInstance.on('progress', ({ progress }) => {
                    const percent = Math.min(100, Math.max(0, (progress || 0) * 100));
                    updateProgress(percent, `Processing video... ${percent.toFixed(1)}%`);
                });

                await ffmpegInstance.load({
                    coreURL: './ffmpeg-core.js',
                    wasmURL: './ffmpeg-core.wasm'
                });

                return true;
            } catch (error) {
                console.error('Error loading FFmpeg:', error);
                alert(`Error loading FFmpeg: ${error.message}`);
                return false;
            }
        }

        async function processFiles() {
            if (!audioFiles.length || !imageFile) return;

            processBtn.disabled = true;
            processedVideos = [];
            videoGrid.innerHTML = '';
            downloadAllBtn.style.display = 'none';
            progressContainer.style.display = 'block';
            logOutput.textContent = '';

            updateProgress(0, 'Loading FFmpeg...');
            const loaded = await loadFFmpeg();
            if (!loaded) {
                processBtn.disabled = false;
                return;
            }

            updateProgress(10, 'FFmpeg loaded, preparing files...');

            try {
                // Write image file to FFmpeg filesystem
                const imageData = await readFileAsArrayBuffer(imageFile);
                const imageExt = getFileExtension(imageFile.name);
                const imageFilename = `input_image${imageExt}`;
                await ffmpegInstance.writeFile(imageFilename, new Uint8Array(imageData));

                // Process each audio file
                for (let i = 0; i < audioFiles.length; i++) {
                    const audioFile = audioFiles[i];
                    const baseProgress = 10 + (i / audioFiles.length) * 80;
                    
                    updateProgress(baseProgress, `Processing ${i + 1}/${audioFiles.length}: ${audioFile.name}`);

                    try {
                        const video = await processAudioWithImage(audioFile, imageFilename, i);
                        if (video) {
                            processedVideos.push(video);
                            addVideoToGrid(video);
                        }
                    } catch (error) {
                        console.error(`Error processing ${audioFile.name}:`, error);
                        addErrorToGrid(audioFile.name, error.message);
                    }
                }

                updateProgress(100, `Complete! Created ${processedVideos.length} videos`);
                
                if (processedVideos.length > 0) {
                    downloadAllBtn.style.display = 'block';
                }

            } catch (error) {
                console.error('Processing error:', error);
                updateProgress(0, `Error: ${error.message}`);
            }

            processBtn.disabled = false;
        }

        async function processAudioWithImage(audioFile, imageFilename, index) {
            const audioExt = getFileExtension(audioFile.name);
            const audioFilename = `audio_${index}${audioExt}`;
            const outputFilename = `output_${index}.mp4`;

            // Write audio file
            const audioData = await readFileAsArrayBuffer(audioFile.blob);
            await ffmpegInstance.writeFile(audioFilename, new Uint8Array(audioData));

            // Get audio duration
            const duration = await getAudioDuration(audioFile.blob);

            // Create video with static image and audio
            const command = [
                '-loop', '1',
                '-i', imageFilename,
                '-i', audioFilename,
                '-c:v', 'libx264',
                '-tune', 'stillimage',
                '-c:a', 'aac',
                '-b:a', '192k',
                '-pix_fmt', 'yuv420p',
                '-shortest',
                '-movflags', '+faststart',
                outputFilename
            ];

            await ffmpegInstance.exec(command);

            // Read output
            const outputData = await ffmpegInstance.readFile(outputFilename);
            const videoBlob = new Blob([outputData.buffer], { type: 'video/mp4' });

            // Cleanup
            await ffmpegInstance.deleteFile(audioFilename);
            await ffmpegInstance.deleteFile(outputFilename);

            const videoName = audioFile.name.replace(/\.[^/.]+$/, '') + '.mp4';
            
            return {
                name: videoName,
                blob: videoBlob,
                originalAudio: audioFile.name
            };
        }

        function addVideoToGrid(video) {
            const videoItem = document.createElement('div');
            videoItem.className = 'video-item';
            
            const videoElement = document.createElement('video');
            videoElement.controls = true;
            videoElement.src = URL.createObjectURL(video.blob);
            
            const title = document.createElement('h4');
            title.textContent = video.name;
            
            const status = document.createElement('div');
            status.innerHTML = `<span class="status-indicator status-success"></span>Video created successfully`;
            status.style.color = '#48bb78';
            status.style.textAlign = 'center';
            
            videoItem.appendChild(title);
            videoItem.appendChild(videoElement);
            videoItem.appendChild(status);
            
            videoGrid.appendChild(videoItem);
        }

        function addErrorToGrid(audioName, errorMessage) {
            const errorItem = document.createElement('div');
            errorItem.className = 'video-item';
            errorItem.style.borderColor = '#f56565';
            
            const title = document.createElement('h4');
            title.textContent = audioName;
            
            const status = document.createElement('div');
            status.innerHTML = `<span class="status-indicator status-error"></span>Error: ${errorMessage}`;
            status.style.color = '#f56565';
            status.style.textAlign = 'center';
            
            errorItem.appendChild(title);
            errorItem.appendChild(status);
            
            videoGrid.appendChild(errorItem);
        }

        async function downloadAllVideos() {
            if (processedVideos.length === 0) return;

            updateProgress(0, 'Creating zip file...');
            downloadAllBtn.disabled = true;

            try {
                const zip = new JSZip();
                
                for (let i = 0; i < processedVideos.length; i++) {
                    const video = processedVideos[i];
                    const progress = (i / processedVideos.length) * 100;
                    updateProgress(progress, `Adding ${video.name} to zip...`);
                    
                    const arrayBuffer = await video.blob.arrayBuffer();
                    zip.file(video.name, arrayBuffer);
                }

                updateProgress(90, 'Generating zip file...');
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                
                updateProgress(100, 'Download starting...');
                saveAs(zipBlob, 'converted_videos.zip');
                
                setTimeout(() => {
                    updateProgress(0, 'Ready for next batch');
                }, 2000);

            } catch (error) {
                console.error('Error creating zip:', error);
                alert('Error creating zip file: ' + error.message);
            }

            downloadAllBtn.disabled = false;
        }

        function updateProgress(percent, text) {
            progressBar.style.width = percent + '%';
            progressText.textContent = text;
        }

        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        function getAudioDuration(audioBlob) {
            return new Promise((resolve, reject) => {
                const audio = document.createElement('audio');
                const url = URL.createObjectURL(audioBlob);
                
                audio.addEventListener('loadedmetadata', () => {
                    URL.revokeObjectURL(url);
                    resolve(audio.duration);
                });
                
                audio.addEventListener('error', (e) => {
                    URL.revokeObjectURL(url);
                    reject(new Error('Could not load audio metadata'));
                });
                
                audio.src = url;
            });
        }

        function getFileExtension(filename) {
            const lastDot = filename.lastIndexOf('.');
            return lastDot === -1 ? '' : filename.substring(lastDot).toLowerCase();
        }

        // Initialize
        window.addEventListener('load', () => {
            updateProcessButton();
        });
    </script>
</body>
</html>