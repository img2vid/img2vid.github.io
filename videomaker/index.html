
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra-Fast Bulk Audio + Image to Video Converter</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        h1, h2 {
            color: #4a5568;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        .upload-box {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 30px 20px;
            text-align: center;
            background: linear-gradient(145deg, #f7fafc, #edf2f7);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .upload-box:hover {
            border-color: #667eea;
            background: linear-gradient(145deg, #edf2f7, #e2e8f0);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #667eea;
        }
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #4a5568;
        }
        input[type="file"] {
            display: none;
        }
        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-weight: 600;
        }
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }
        button {
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 10px;
            position: relative;
            overflow: hidden;
        }
        button.primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        button.primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(102, 126, 234, 0.4);
        }
        button.primary:disabled {
            background: #cbd5e0;
            color: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .settings-section {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        .settings-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }
        .setting-item label {
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .setting-item select, .setting-item input {
            padding: 8px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            background: white;
            width: 100%;
        }
        .performance-info {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            font-weight: 600;
        }
        .file-info {
            font-size: 0.9em;
            color: #718096;
            margin-top: 10px;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        .progress-container {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            backdrop-filter: blur(5px);
            display: none;
        }
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(203, 213, 224, 0.5);
            border-radius: 20px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            border-radius: 20px;
            transition: width 0.3s ease;
            position: relative;
        }
        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #4a5568;
            margin: 10px 0;
        }
        .batch-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .batch-item {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border-left: 4px solid #cbd5e0;
            transition: all 0.3s ease;
        }
        .batch-item.processing {
            border-left-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }
        .batch-item.completed {
            border-left-color: #48bb78;
            background: rgba(72, 187, 120, 0.1);
        }
        .batch-item.error {
            border-left-color: #f56565;
            background: rgba(245, 101, 101, 0.1);
        }
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        .video-item {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .video-item:hover {
            transform: translateY(-5px);
        }
        .video-item video {
            width: 100%;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .video-item h4 {
            margin: 0 0 10px 0;
            color: #4a5568;
            text-align: center;
        }
        .download-all-btn {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
            width: 100%;
            margin-top: 30px;
            font-size: 1.2em;
            padding: 20px;
        }
        .download-all-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(72, 187, 120, 0.4);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .processing-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #667eea;
            animation: pulse 1.5s infinite;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° Ultra-Fast Bulk Audio + Image to Video Converter</h1>
        
        <div class="performance-info">
            üöÄ PERFORMANCE OPTIMIZED: Parallel processing, optimized settings, and batch operations for maximum speed!
        </div>
        
        <div class="upload-section">
            <div class="upload-box" onclick="document.getElementById('zipFile').click()">
                <div class="upload-icon">üì¶</div>
                <label for="zipFile">Select Audio Zip File:</label>
                <input type="file" id="zipFile" accept=".zip" />
                <div class="file-input-label">Choose Zip File</div>
                <div class="file-info" id="zipInfo" style="display: none;"></div>
            </div>
            
            <div class="upload-box" onclick="document.getElementById('imageFile').click()">
                <div class="upload-icon">üñºÔ∏è</div>
                <label for="imageFile">Select Image File:</label>
                <input type="file" id="imageFile" accept="image/*" />
                <div class="file-input-label">Choose Image</div>
                <div class="file-info" id="imageInfo" style="display: none;"></div>
            </div>
        </div>

        <div class="settings-section">
            <h3>‚öôÔ∏è Performance Settings</h3>
            <div class="settings-row">
                <div class="setting-item">
                    <label>Video Quality (Speed vs Quality):</label>
                    <select id="qualityPreset">
                        <option value="ultrafast">Ultra Fast (Lowest Quality)</option>
                        <option value="superfast" selected>Super Fast (Low Quality)</option>
                        <option value="veryfast">Very Fast (Medium Quality)</option>
                        <option value="faster">Faster (Good Quality)</option>
                        <option value="fast">Fast (High Quality)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>Batch Size (Parallel Processing):</label>
                    <select id="batchSize">
                        <option value="2">2 files at once</option>
                        <option value="4" selected>4 files at once</option>
                        <option value="6">6 files at once</option>
                        <option value="8">8 files at once</option>
                    </select>
                </div>
            </div>
            <div class="settings-row">
                <div class="setting-item">
                    <label>Video Resolution:</label>
                    <select id="resolution">
                        <option value="480p">480p (Fastest)</option>
                        <option value="720p" selected>720p (Balanced)</option>
                        <option value="1080p">1080p (Slower)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>Audio Bitrate:</label>
                    <select id="audioBitrate">
                        <option value="96k">96k (Fastest)</option>
                        <option value="128k" selected>128k (Balanced)</option>
                        <option value="192k">192k (Higher Quality)</option>
                    </select>
                </div>
            </div>
        </div>

        <div style="text-align: center;">
            <button id="processBtn" class="primary" disabled>
                ‚ö° ULTRA-FAST PROCESS & CREATE VIDEOS
            </button>
        </div>

        <div class="progress-container" id="progressContainer">
            <h3>Processing Progress</h3>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-text" id="progressText">Ready...</div>
            <div class="batch-status" id="batchStatus"></div>
        </div>

        <div class="video-grid" id="videoGrid"></div>

        <button id="downloadAllBtn" class="download-all-btn" style="display: none;">
            üì• Download All Videos as Zip
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ffmpeg/0.12.10/ffmpeg.min.js"></script>
    <script>
        let ffmpegInstance = null;
        let processedVideos = [];
        let audioFiles = [];
        let imageFile = null;
        let processingStartTime = null;

        // DOM Elements
        const zipFileInput = document.getElementById('zipFile');
        const imageFileInput = document.getElementById('imageFile');
        const processBtn = document.getElementById('processBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const videoGrid = document.getElementById('videoGrid');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const zipInfo = document.getElementById('zipInfo');
        const imageInfo = document.getElementById('imageInfo');
        const batchStatus = document.getElementById('batchStatus');

        // Settings
        const qualityPreset = document.getElementById('qualityPreset');
        const batchSize = document.getElementById('batchSize');
        const resolution = document.getElementById('resolution');
        const audioBitrate = document.getElementById('audioBitrate');

        // Event Listeners
        zipFileInput.addEventListener('change', handleZipUpload);
        imageFileInput.addEventListener('change', handleImageUpload);
        processBtn.addEventListener('click', processFiles);
        downloadAllBtn.addEventListener('click', downloadAllVideos);

        async function handleZipUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            zipInfo.textContent = 'Reading zip file...';
            zipInfo.style.display = 'block';

            try {
                const zip = new JSZip();
                const zipContent = await zip.loadAsync(file);
                audioFiles = [];

                let fileCount = 0;
                for (const [filename, zipEntry] of Object.entries(zipContent.files)) {
                    if (!zipEntry.dir && isAudioFile(filename)) {
                        const blob = await zipEntry.async('blob');
                        audioFiles.push({
                            name: filename,
                            blob: blob
                        });
                        fileCount++;
                    }
                }

                if (fileCount === 0) {
                    zipInfo.innerHTML = '<span style="color: #f56565;">‚ùå No audio files found in zip</span>';
                } else {
                    zipInfo.innerHTML = `<strong>‚úÖ Found ${fileCount} audio files</strong><br>Ready for ultra-fast processing!`;
                }
                zipInfo.style.display = 'block';
                updateProcessButton();
                
                console.log('Audio files loaded:', audioFiles.length);
            } catch (error) {
                console.error('Error reading zip file:', error);
                zipInfo.innerHTML = `<span style="color: #f56565;">‚ùå Error reading zip file: ${error.message}</span>`;
                zipInfo.style.display = 'block';
            }
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.type.startsWith('image/')) {
                imageInfo.innerHTML = '<span style="color: #f56565;">‚ùå Please select a valid image file</span>';
                imageInfo.style.display = 'block';
                imageFile = null;
                updateProcessButton();
                return;
            }

            imageFile = file;
            imageInfo.innerHTML = `<strong>‚úÖ ${file.name}</strong><br>Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`;
            imageInfo.style.display = 'block';
            updateProcessButton();
            
            console.log('Image file loaded:', file.name);
        }

        function updateProcessButton() {
            const hasAudio = audioFiles && audioFiles.length > 0;
            const hasImage = imageFile !== null;
            
            console.log('Button update - Audio files:', hasAudio ? audioFiles.length : 0, 'Image:', hasImage);
            
            processBtn.disabled = !hasAudio || !hasImage;
            
            if (processBtn.disabled) {
                processBtn.style.opacity = '0.5';
                processBtn.textContent = hasAudio ? 
                    (hasImage ? '‚ö° PROCESSING READY' : 'üì∑ SELECT IMAGE FILE') : 
                    'üì¶ SELECT AUDIO ZIP FILE';
            } else {
                processBtn.style.opacity = '1';
                processBtn.textContent = '‚ö° ULTRA-FAST PROCESS & CREATE VIDEOS';
            }
        }

        function isAudioFile(filename) {
            const audioExtensions = ['.mp3', '.wav', '.m4a', '.aac', '.ogg', '.flac', '.wma'];
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return audioExtensions.includes(ext);
        }

        async function loadFFmpeg() {
            if (ffmpegInstance) return true;

            try {
                ffmpegInstance = new FFmpeg();
                
                ffmpegInstance.on('log', ({ type, message }) => {
                    console.log(`[FFmpeg] [${type}] ${message}`);
                });

                await ffmpegInstance.load({
                    coreURL: "https://cdnjs.cloudflare.com/ajax/libs/ffmpeg/0.12.10/ffmpeg-core.js",
                    wasmURL: "https://cdnjs.cloudflare.com/ajax/libs/ffmpeg/0.12.10/ffmpeg-core.wasm",
                });
                
                return true;
            } catch (error) {
                console.error('Error loading FFmpeg:', error);
                alert(`Error loading FFmpeg: ${error.message}\n\nTry refreshing the page and uploading files again.`);
                return false;
            }
        }

        async function processFiles() {
            if (!audioFiles.length || !imageFile) return;

            processingStartTime = Date.now();
            processBtn.disabled = true;
            processedVideos = [];
            videoGrid.innerHTML = '';
            downloadAllBtn.style.display = 'none';
            progressContainer.style.display = 'block';
            batchStatus.innerHTML = '';

            updateProgress(0, 'Initializing ultra-fast processing...');

            const loaded = await loadFFmpeg();
            if (!loaded) {
                processBtn.disabled = false;
                return;
            }

            updateProgress(5, 'Preparing optimized image...');

            try {
                // Prepare optimized image
                const optimizedImage = await prepareOptimizedImage(imageFile);
                const imageData = await readFileAsArrayBuffer(optimizedImage);
                const imageFilename = 'input_image.jpg';
                await ffmpegInstance.writeFile(imageFilename, new Uint8Array(imageData));

                // Process files in parallel batches
                const batchSizeNum = parseInt(batchSize.value);
                const batches = [];
                
                for (let i = 0; i < audioFiles.length; i += batchSizeNum) {
                    batches.push(audioFiles.slice(i, i + batchSizeNum));
                }

                updateProgress(10, `Processing ${audioFiles.length} files in ${batches.length} ultra-fast batches...`);

                // Initialize batch status display
                initializeBatchStatus(audioFiles);

                let completed = 0;
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    const batch = batches[batchIndex];
                    const batchPromises = batch.map((audioFile, index) => 
                        processSingleAudio(audioFile, imageFilename, completed + index)
                    );

                    const batchResults = await Promise.allSettled(batchPromises);
                    
                    batchResults.forEach((result, index) => {
                        const audioIndex = completed + index;
                        if (result.status === 'fulfilled' && result.value) {
                            processedVideos.push(result.value);
                            addVideoToGrid(result.value);
                            updateBatchItemStatus(audioIndex, 'completed');
                        } else {
                            console.error(`Error processing ${batch[index].name}:`, result.reason);
                            updateBatchItemStatus(audioIndex, 'error');
                        }
                    });

                    completed += batch.length;
                    const overallProgress = 10 + (completed / audioFiles.length) * 85;
                    const elapsed = (Date.now() - processingStartTime) / 1000;
                    const rate = completed / elapsed;
                    const remaining = (audioFiles.length - completed) / rate;
                    
                    updateProgress(overallProgress, 
                        `Batch ${batchIndex + 1}/${batches.length} complete! ` +
                        `${completed}/${audioFiles.length} files (${rate.toFixed(1)}/sec, ~${remaining.toFixed(0)}s remaining)`
                    );
                }

                const totalTime = (Date.now() - processingStartTime) / 1000;
                const rate = audioFiles.length / totalTime;
                
                updateProgress(100, 
                    `üéâ COMPLETE! Processed ${processedVideos.length}/${audioFiles.length} files ` +
                    `in ${totalTime.toFixed(1)}s (${rate.toFixed(1)} files/sec)`
                );
                
                if (processedVideos.length > 0) {
                    downloadAllBtn.style.display = 'block';
                }

            } catch (error) {
                console.error('Processing error:', error);
                updateProgress(0, `Error: ${error.message}`);
            }

            processBtn.disabled = false;
        }

        async function prepareOptimizedImage(imageFile) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    // Get target resolution
                    const resValue = resolution.value;
                    let targetHeight;
                    switch(resValue) {
                        case '480p': targetHeight = 480; break;
                        case '720p': targetHeight = 720; break;
                        case '1080p': targetHeight = 1080; break;
                        default: targetHeight = 720;
                    }
                    
                    // Calculate dimensions maintaining aspect ratio
                    const aspectRatio = img.width / img.height;
                    canvas.height = targetHeight;
                    canvas.width = Math.round(targetHeight * aspectRatio);
                    
                    // Ensure even dimensions for video encoding
                    if (canvas.width % 2 !== 0) canvas.width++;
                    if (canvas.height % 2 !== 0) canvas.height++;
                    
                    // Draw and optimize
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    canvas.toBlob(resolve, 'image/jpeg', 0.85);
                };
                
                img.src = URL.createObjectURL(imageFile);
            });
        }

        function initializeBatchStatus(files) {
            batchStatus.innerHTML = '';
            files.forEach((file, index) => {
                const item = document.createElement('div');
                item.className = 'batch-item';
                item.id = `batch-item-${index}`;
                item.innerHTML = `
                    <div style="font-weight: bold; font-size: 0.9em;">${file.name}</div>
                    <div style="font-size: 0.8em; margin-top: 5px;">Waiting...</div>
                `;
                batchStatus.appendChild(item);
            });
        }

        function updateBatchItemStatus(index, status) {
            const item = document.getElementById(`batch-item-${index}`);
            if (!item) return;
            
            item.className = `batch-item ${status}`;
            const statusText = item.querySelector('div:last-child');
            
            switch(status) {
                case 'processing':
                    statusText.innerHTML = '<span class="processing-indicator"></span>Processing...';
                    break;
                case 'completed':
                    statusText.innerHTML = '‚úÖ Complete';
                    break;
                case 'error':
                    statusText.innerHTML = '‚ùå Error';
                    break;
            }
        }

        async function processSingleAudio(audioFile, imageFilename, index) {
            updateBatchItemStatus(index, 'processing');
            
            const audioExt = getFileExtension(audioFile.name);
            const audioFilename = `audio_${index}${audioExt}`;
            const outputFilename = `output_${index}.mp4`;

            try {
                // Write audio file
                const audioData = await readFileAsArrayBuffer(audioFile.blob);
                await ffmpegInstance.writeFile(audioFilename, new Uint8Array(audioData));

                // Ultra-optimized FFmpeg command for speed
                const preset = qualityPreset.value;
                const bitrate = audioBitrate.value;
                
                const command = [
                    '-loop', '1',
                    '-i', imageFilename,
                    '-i', audioFilename,
                    '-c:v', 'libx264',
                    '-preset', preset,
                    '-tune', 'stillimage',
                    '-crf', '28', // Higher CRF for faster encoding
                    '-c:a', 'aac',
                    '-b:a', bitrate,
                    '-pix_fmt', 'yuv420p',
                    '-vf', 'scale=trunc(iw/2)*2:trunc(ih/2)*2', // Ensure even dimensions
                    '-shortest',
                    '-movflags', '+faststart',
                    '-threads', '0', // Use all available threads
                    outputFilename
                ];

                await ffmpegInstance.run(...command);

                // Read output
                const outputData = await ffmpegInstance.readFile(outputFilename);
                const videoBlob = new Blob([outputData.buffer], { type: 'video/mp4' });

                // Cleanup immediately
                await ffmpegInstance.deleteFile(audioFilename);
                await ffmpegInstance.deleteFile(outputFilename);

                const videoName = audioFile.name.replace(/\.[^/.]+$/, '') + '.mp4';
                
                return {
                    name: videoName,
                    blob: videoBlob,
                    originalAudio: audioFile.name
                };
            } catch (error) {
                console.error(`Error processing ${audioFile.name}:`, error);
                throw error;
            }
        }

        function addVideoToGrid(video) {
            const videoItem = document.createElement('div');
            videoItem.className = 'video-item';
            
            const videoElement = document.createElement('video');
            videoElement.controls = true;
            videoElement.src = URL.createObjectURL(video.blob);
            videoElement.preload = 'metadata'; // Only load metadata for faster rendering
            
            const title = document.createElement('h4');
            title.textContent = video.name;
            
            const status = document.createElement('div');
            status.innerHTML = `‚úÖ Ready for download`;
            status.style.color = '#48bb78';
            status.style.textAlign = 'center';
            
            videoItem.appendChild(title);
            videoItem.appendChild(videoElement);
            videoItem.appendChild(status);
            
            videoGrid.appendChild(videoItem);
        }

        async function downloadAllVideos() {
            if (processedVideos.length === 0) return;

            updateProgress(0, 'Creating zip file...');
            downloadAllBtn.disabled = true;

            try {
                const zip = new JSZip();
                
                // Add all videos to zip in parallel for speed
                const addPromises = processedVideos.map(async (video, i) => {
                    const progress = (i / processedVideos.length) * 90;
                    updateProgress(progress, `Adding ${video.name} to zip...`);
                    
                    const arrayBuffer = await video.blob.arrayBuffer();
                    zip.file(video.name, arrayBuffer);
                });

                await Promise.all(addPromises);

                updateProgress(90, 'Generating zip file...');
                const zipBlob = await zip.generateAsync({ 
                    type: 'blob',
                    compression: 'STORE' // No compression for speed
                });
                
                updateProgress(100, 'Download starting...');
                saveAs(zipBlob, `videos_${Date.now()}.zip`);
                
                setTimeout(() => {
                    updateProgress(0, 'Ready for next batch!');
                }, 2000);

            } catch (error) {
                console.error('Error creating zip:', error);
                alert('Error creating zip file: ' + error.message);
            }

            downloadAllBtn.disabled = false;
        }

        function updateProgress(percent, text) {
            progressBar.style.width = percent + '%';
            progressText.textContent = text;
        }

        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        function getFileExtension(filename) {
            const lastDot = filename.lastIndexOf('.');
            return lastDot === -1 ? '' : filename.substring(lastDot).toLowerCase();
        }

        // Initialize
        window.addEventListener('load', () => {
            updateProcessButton();
        });
    </script>
</body>
</html>