<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio ZIP + Image to Videos Converter</title>
    <script src="./jszip.min.js"></script> <script src="./ffmpeg.min.js"></script> 
    <style>
        body {
            font-family: 'Inter', sans-serif;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }
        .container {
            width: 100%;
            max-width: 700px;
            margin: 20px;
            background: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }
        h1 {
            color: #1a202c;
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.8em;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }
        input[type="file"], select {
            display: block;
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 20px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 0.95em;
            background-color: #f7fafc;
        }
        input[type="file"]::-webkit-file-upload-button {
            padding: 10px 15px;
            border: none;
            background-color: #4299e1;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-right: 10px;
            font-weight: 500;
        }
        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #2b6cb0;
        }
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background-color 0.3s ease, box-shadow 0.2s ease;
            margin-top: 10px;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        button.primary {
            background-color: #48bb78;
            color: white;
        }
        button.primary:hover {
            background-color: #38a169;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:disabled {
            background-color: #a0aec0;
            color: #e2e8f0;
            cursor: not-allowed;
            box-shadow: none;
        }
        #progress-container, #log-container, #output-videos-container { /* Updated ID */
            margin-top: 25px;
            padding: 20px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #f7fafc;
        }
        #progress-container h2, #log-container h2, #output-videos-container h2 { /* Updated ID */
             margin-top: 0;
             margin-bottom: 15px;
             color: #2d3748;
             font-size: 1.25em;
             border-bottom: 1px solid #e2e8f0;
             padding-bottom: 10px;
        }
        #progress-bar-container {
            width: 100%;
            background-color: #e2e8f0;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 10px;
            height: 24px;
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background-color: #4299e1;
            text-align: center;
            line-height: 24px;
            color: white;
            font-size: 0.85em;
            font-weight: 600;
            transition: width 0.3s ease-out;
        }
        #progress-text {
            font-size: 0.95em;
            color: #4a5568;
            text-align: center;
        }
        #log {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.85em;
            background-color: #ffffff;
            padding: 15px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            color: #2d3748;
        }
        a.download-link {
            display: block; /* Changed to block for individual links */
            margin-top: 10px;
            margin-bottom: 10px; /* Added margin bottom */
            padding: 10px 18px;
            background-color: #48bb78;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 600;
            transition: background-color 0.3s ease;
            text-align: center; /* Center text in button-like link */
        }
        a.download-link:hover {
            background-color: #38a169;
        }
        .file-info {
            font-size: 0.8em;
            color: #718096;
            margin-top: -15px;
            margin-bottom: 15px;
        }
        .hidden {
            display: none;
        }
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .message-box-content {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }
        .message-box-content p {
            margin: 0 0 15px 0;
            color: #4a5568;
        }
        .message-box-content button {
            background-color: #4299e1;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            width: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio ZIP + Image to Videos Converter</h1>
        <p>Upload a ZIP file containing your audio tracks and a single image. Videos will be created for each audio track using the image and made available for individual download.</p>

        <div>
            <label for="audioZipInput">Select Audio ZIP File:</label>
            <input type="file" id="audioZipInput" accept=".zip">
            <div class="file-info">A ZIP file containing one or more audio files (e.g., .mp3, .wav, .m4a).</div>
        </div>

        <div>
            <label for="imageInput">Select Single Image File:</label>
            <input type="file" id="imageInput" accept="image/*">
            <div class="file-info">A single image file (e.g., .png, .jpg, .jpeg, .webp).</div>
        </div>
        
        <div>
            <label for="outputFormatSelect">Output Video Format (for all videos):</label>
            <select id="outputFormatSelect">
                <option value="mp4" selected>MP4 (H.264/AAC)</option>
                <option value="mov">MOV (H.264/AAC)</option>
            </select>
        </div>

        <button id="generateButton" class="primary" disabled>Load FFmpeg & Generate</button>

        <div id="progress-container" class="hidden">
            <h2>Processing Progress</h2>
            <div id="progress-bar-container">
                <div id="progressBar">0%</div>
            </div>
            <div id="progress-text">Preparing...</div>
        </div>

        <div id="log-container" class="hidden">
            <h2>FFmpeg Log</h2>
            <pre id="log"></pre>
        </div>

        <div id="output-videos-container" class="hidden"> <h2>Download Generated Videos</h2> </div>
    </div>

    <script>
        const { FFmpeg: FFmpegClass } = FFmpegWASM;
        let ffmpegInstance = null;
        let isProcessing = false;

        const audioZipInput = document.getElementById('audioZipInput');
        const imageInput = document.getElementById('imageInput');
        const outputFormatSelect = document.getElementById('outputFormatSelect');
        const generateButton = document.getElementById('generateButton');
        
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progress-text');
        
        const logContainer = document.getElementById('log-container');
        const logElement = document.getElementById('log');
        
        const outputVideosContainer = document.getElementById('output-videos-container'); // Updated variable name

        function showMessage(message) {
            const overlay = document.createElement('div');
            overlay.className = 'message-box-overlay';
            const content = document.createElement('div');
            content.className = 'message-box-content';
            const text = document.createElement('p');
            text.textContent = message;
            const closeButton = document.createElement('button');
            closeButton.textContent = 'OK';
            closeButton.onclick = () => overlay.remove();
            content.appendChild(text);
            content.appendChild(closeButton);
            overlay.appendChild(content);
            document.body.appendChild(overlay);
            closeButton.focus();
        }

        async function loadFFmpeg() {
            if (ffmpegInstance) return true;
            generateButton.textContent = 'Loading FFmpeg Core...';
            generateButton.disabled = true;
            console.log('Creating FFmpeg instance...');
            try {
                ffmpegInstance = new FFmpegClass(); 
                ffmpegInstance.on('log', ({ type, message }) => {
                    if (isProcessing) {
                        console.log(`[FFmpeg] [${type}] ${message}`);
                        logElement.textContent += message + "\n";
                        logElement.scrollTop = logElement.scrollHeight;
                    }
                });
                ffmpegInstance.on('progress', ({ progress, time }) => {
                     if (isProcessing && progress && typeof progress === 'number') {
                        const currentVideoProgress = Math.min(100, Math.max(0, progress * 100));
                        console.log(`FFmpeg task progress: ${currentVideoProgress.toFixed(1)}%`);
                    }
                });
                await ffmpegInstance.load({ corePath: './ffmpeg-core.js' });
                console.log('FFmpeg core loaded successfully.');
                generateButton.textContent = 'Generate Videos'; // Updated button text
                updateGenerateButtonState(); 
                return true;
            } catch (error) {
                console.error('Error loading FFmpeg:', error);
                generateButton.textContent = 'Error Loading FFmpeg';
                generateButton.disabled = true;
                showMessage(`Error loading FFmpeg: ${error.message || error}. Please check console and refresh.`);
                return false;
            }
        }

        function updateGenerateButtonState() {
            const audioFile = audioZipInput.files.length > 0;
            const imageFile = imageInput.files.length > 0;
            if (ffmpegInstance && !isProcessing) {
                generateButton.disabled = !(audioFile && imageFile);
            } else if (!ffmpegInstance) {
                 generateButton.disabled = true;
            }
        }

        function readFileAsUint8Array(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = event => resolve(new Uint8Array(event.target.result));
                reader.onerror = error => reject(error);
                reader.readAsArrayBuffer(file);
            });
        }

        function getAudioDuration(audioFile) {
            return new Promise((resolve, reject) => {
                if (!audioFile || !audioFile.type.startsWith('audio/')) {
                    return reject(new Error("Invalid or missing audio file for duration check."));
                }
                const tempAudio = document.createElement('audio');
                const objectURL = URL.createObjectURL(audioFile);
                tempAudio.preload = 'metadata';
                const cleanup = () => {
                    tempAudio.removeEventListener('loadedmetadata', onLoadedMetadata);
                    tempAudio.removeEventListener('error', onError);
                    URL.revokeObjectURL(objectURL);
                };
                const onLoadedMetadata = () => {
                    const duration = tempAudio.duration;
                    cleanup();
                    if (isNaN(duration) || !isFinite(duration) || duration <= 0) {
                       reject(new Error(`Could not determine a valid positive duration for ${audioFile.name}. Duration: ${duration}`));
                    } else {
                       resolve(duration);
                    }
                };
                const onError = (e) => {
                    cleanup();
                    console.error(`Error loading audio metadata for ${audioFile.name}:`, e);
                    reject(new Error(`Failed to load metadata for ${audioFile.name}. Check file format or content.`));
                };
                tempAudio.addEventListener('loadedmetadata', onLoadedMetadata);
                tempAudio.addEventListener('error', onError);
                tempAudio.src = objectURL;
            });
        }

        function getFileExtension(filename) {
            const lastDot = filename.lastIndexOf('.');
            if (lastDot === -1) return '';
            return filename.substring(lastDot).toLowerCase();
        }
        
        function getFilenameWithoutExtension(filename) {
            const lastDot = filename.lastIndexOf('.');
            if (lastDot === -1) return filename;
            return filename.substring(0, lastDot);
        }

        async function generateAndZipVideos() { // Function name kept for consistency, though zipping is removed
            if (isProcessing) {
                showMessage("Processing is already in progress.");
                return;
            }
            if (!audioZipInput.files.length || !imageInput.files.length) {
                showMessage("Please select both an audio ZIP file and an image file.");
                return;
            }

            const ffmpegLoaded = await loadFFmpeg();
            if (!ffmpegLoaded) return;

            isProcessing = true;
            generateButton.disabled = true;
            audioZipInput.disabled = true;
            imageInput.disabled = true;
            outputFormatSelect.disabled = true;

            progressContainer.classList.remove('hidden');
            logContainer.classList.remove('hidden');
            outputVideosContainer.innerHTML = ''; // Clear previous download links
            outputVideosContainer.classList.add('hidden'); // Hide until videos are ready

            logElement.textContent = '';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            progressText.textContent = 'Starting...';

            const outputVideoFormat = outputFormatSelect.value;
            let videosGeneratedCount = 0;

            try {
                progressText.textContent = 'Reading image file...';
                const imageFile = imageInput.files[0];
                const imageExtension = getFileExtension(imageFile.name) || '.png';
                const imageFilenameInFS = `static_image${imageExtension}`;
                const imageData = await readFileAsUint8Array(imageFile);
                ffmpegInstance.FS('writeFile', imageFilenameInFS, imageData);
                logElement.textContent += `Image "${imageFile.name}" written to virtual FS as "${imageFilenameInFS}".\n`;

                progressText.textContent = 'Extracting audio files from ZIP...';
                logElement.textContent += 'Reading audio ZIP...\n';
                const zipFile = audioZipInput.files[0];
                const jszip = new JSZip(); // JSZip is still used for unzipping the input
                const zip = await jszip.loadAsync(zipFile);
                
                const audioFileEntries = [];
                zip.forEach((relativePath, zipEntry) => {
                    const lowerRelativePath = relativePath.toLowerCase();
                    if (!zipEntry.dir && (lowerRelativePath.endsWith('.mp3') || lowerRelativePath.endsWith('.wav') || lowerRelativePath.endsWith('.m4a') || lowerRelativePath.endsWith('.aac') || lowerRelativePath.endsWith('.ogg') || lowerRelativePath.endsWith('.flac'))) {
                        audioFileEntries.push(zipEntry);
                    }
                });

                if (audioFileEntries.length === 0) {
                    throw new Error("No audio files found in the ZIP.");
                }
                logElement.textContent += `Found ${audioFileEntries.length} audio file(s) in ZIP.\n`;

                for (let i = 0; i < audioFileEntries.length; i++) {
                    const audioEntry = audioFileEntries[i];
                    const originalAudioFilename = audioEntry.name.split('/').pop();
                    const audioData = await audioEntry.async('uint8array');
                    
                    const currentOverallProgress = (((i) / audioFileEntries.length) * 100).toFixed(0);
                    progressBar.style.width = `${currentOverallProgress}%`;
                    progressBar.textContent = `${currentOverallProgress}%`;
                    progressText.textContent = `Processing video ${i + 1} of ${audioFileEntries.length}: ${originalAudioFilename}`;
                    logElement.textContent += `\n--- Processing: ${originalAudioFilename} ---\n`;

                    const audioBlob = new Blob([audioData], { type: `audio/${getFileExtension(originalAudioFilename).substring(1) || 'mpeg'}` });
                    const audioFileForDuration = new File([audioBlob], originalAudioFilename, { type: audioBlob.type });
                    
                    let audioDuration;
                    try {
                        audioDuration = await getAudioDuration(audioFileForDuration);
                         logElement.textContent += `Audio duration: ${audioDuration.toFixed(2)} seconds.\n`;
                    } catch (durationError) {
                        logElement.textContent += `Error getting duration for ${originalAudioFilename}: ${durationError.message}. Skipping this audio.\n`;
                        console.error(`Duration error for ${originalAudioFilename}:`, durationError);
                        continue;
                    }

                    const audioFilenameInFS = `current_audio${getFileExtension(originalAudioFilename)}`;
                    ffmpegInstance.FS('writeFile', audioFilenameInFS, audioData);
                    logElement.textContent += `Audio "${originalAudioFilename}" written to virtual FS as "${audioFilenameInFS}".\n`;

                    const outputVideoFilenameBase = getFilenameWithoutExtension(originalAudioFilename);
                    const outputVideoFilenameInFS = `output_video.${outputVideoFormat}`;
                    
                    const command = [
                        '-loop', '1', '-framerate', '1', '-i', imageFilenameInFS,
                        '-i', audioFilenameInFS,
                        '-vf', `fps=25,scale=trunc(iw/2)*2:trunc(ih/2)*2,format=yuv420p`, 
                        '-c:v', 'libx264', '-tune', 'stillimage', '-preset', 'medium', 
                        '-c:a', 'aac', '-b:a', '128k',
                        '-t', audioDuration.toString(),
                        '-shortest', '-movflags', '+faststart', 
                        outputVideoFilenameInFS
                    ];

                    logElement.textContent += `FFmpeg command: ffmpeg ${command.join(' ')}\n`;
                    await ffmpegInstance.run(...command); 

                    const videoOutputData = ffmpegInstance.FS('readFile', outputVideoFilenameInFS);
                    
                    // Create and append download link for the generated video
                    const videoBlobOut = new Blob([videoOutputData], { type: `video/${outputVideoFormat}` });
                    const videoUrl = URL.createObjectURL(videoBlobOut);
                    const link = document.createElement('a');
                    link.href = videoUrl;
                    const downloadFileName = `${outputVideoFilenameBase}.${outputVideoFormat}`;
                    link.download = downloadFileName;
                    link.textContent = `Download ${downloadFileName}`;
                    link.className = 'download-link';
                    // link.style.display = 'block'; // Class 'download-link' now handles this
                    // link.style.marginBottom = '10px'; // Class 'download-link' now handles this

                    outputVideosContainer.appendChild(link);
                    videosGeneratedCount++;
                    
                    logElement.textContent += `Video for "${originalAudioFilename}" created successfully and download link added.\n`;

                    try { ffmpegInstance.FS('unlink', audioFilenameInFS); } catch(e) { console.warn("Could not delete audio from FS:", e); }
                    try { ffmpegInstance.FS('unlink', outputVideoFilenameInFS); } catch(e) { console.warn("Could not delete video from FS:", e); }
                }

                try { ffmpegInstance.FS('unlink', imageFilenameInFS); } catch(e) { console.warn("Could not delete image from FS:", e); }

                if (videosGeneratedCount === 0) {
                    throw new Error("No videos were successfully generated. Check logs for errors.");
                }
                
                outputVideosContainer.classList.remove('hidden');
                logElement.textContent += `\nAll ${videosGeneratedCount} video(s) processed. Download links available above.\n`;
                progressText.textContent = `All ${videosGeneratedCount} video(s) processed!`;
                progressBar.style.width = '100%';
                progressBar.textContent = '100%';

            } catch (error) {
                console.error('Error during processing:', error);
                progressText.textContent = `Error: ${error.message || error}`;
                let errorMessage = error instanceof Error ? error.message : String(error);
                let errorStack = error instanceof Error ? error.stack : 'N/A';
                logElement.textContent += `\n\nERROR: ${errorMessage}\nStack: ${errorStack}\n`;
                if (error && typeof error === 'object' && 'stderr' in error) {
                    logElement.textContent += `FFmpeg stderr: ${error.stderr}\n`;
                }
                showMessage(`An error occurred: ${errorMessage}. Check the log for details.`);
            } finally {
                isProcessing = false;
                audioZipInput.disabled = false;
                imageInput.disabled = false;
                outputFormatSelect.disabled = false;
                updateGenerateButtonState();
            }
        }

        window.addEventListener('load', () => {
            generateButton.textContent = 'Load FFmpeg & Generate';
            if (typeof FFmpegWASM === 'undefined' || typeof FFmpegWASM.FFmpeg === 'undefined') {
                console.error("FFmpegWASM global or FFmpegWASM.FFmpeg class not found. Ensure ffmpeg.min.js is loaded correctly.");
                generateButton.textContent = 'FFmpeg Script Error';
                generateButton.disabled = true;
                showMessage("Error: ffmpeg.min.js did not load correctly. FFmpegWASM is undefined.");
                return;
            }
            loadFFmpeg().then(loaded => {
                if(loaded) updateGenerateButtonState();
            });
            audioZipInput.addEventListener('change', updateGenerateButtonState);
            imageInput.addEventListener('change', updateGenerateButtonState);
        });

        generateButton.addEventListener('click', generateAndZipVideos);
    </script>
</body>
</html>