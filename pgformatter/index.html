<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Text Cleaner</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 80%;
            max-width: 900px;
            margin: auto;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #34495e;
        }

        input[type="file"] {
            display: block;
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: calc(100% - 22px); /* Account for padding and border */
            cursor: pointer;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            margin-right: 10px;
            margin-top: 10px;
        }

        button:hover {
            background-color: #2980b9;
        }

        button#downloadButton {
            background-color: #2ecc71;
        }

        button#downloadButton:hover {
            background-color: #27ae60;
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        textarea {
            width: 100%;
            height: 300px;
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace; /* Better for viewing text structure */
            font-size: 0.9em;
            box-sizing: border-box; /* Include padding in width/height */
            background-color: #ecf0f1;
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4fd;
            border: 1px solid #bde0fe;
            border-radius: 4px;
            font-size: 0.9em;
            color: #0353a4;
        }

        .info ul {
            margin-top: 10px;
            margin-bottom: 0;
            padding-left: 20px;
        }

        .error {
            color: #c0392b;
            font-weight: bold;
            margin-top: 10px;
        }

        .processing-status {
            margin-top: 15px;
            font-style: italic;
            color: #7f8c8d;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Intelligent Text Cleaner</h1>

    <div class="info">
        <strong>How it works:</strong>
        <ul>
            <li>Upload a plain text (.txt) file.</li>
            <li><strong>If the file contains at least four `***` separators:</strong>
                <ul>
                    <li>Removes all text before the first `***`.</li>
                    <li>Removes the text between the first and second `***` (including the delimiters).</li>
                    <li>Removes all text after the last `***`.</li>
                    <li>Removes the text between the second-to-last and the last `***` (including the delimiters).</li>
                    <li>Keeps only the text between the second and second-to-last `***`.</li>
                </ul>
            </li>
            <li><strong>On the *remaining* text:</strong></li>
                <ul>
                    <li>Removes most line breaks, preserving paragraphs.</li>
                    <li>Intelligently identifies chapter/part/section headings (using keywords, Roman/Arabic numerals, and formatting clues like ALL CAPS lines surrounded by blank lines).</li>
                    <li>Ensures one blank line before and after identified headings.</li>
                    <li>Converts Roman numerals (I, V, X, etc.) to Arabic numerals (1, 5, 10, etc.) ONLY within detected headings. It avoids converting standalone "I" or Roman numerals in regular text.</li>
                    <li>Removes all underscore (_) characters.</li>
                    <li>Removes all text enclosed in square brackets (e.g., "[Editor's note]").</li>
                </ul>
            <li>Provides a processed version for viewing and download.</li>
        </ul>
    </div>

    <label for="fileInput">Upload your .txt file:</label>
    <input type="file" id="fileInput" accept=".txt">

    <div id="status" class="processing-status"></div>
    <div id="error" class="error"></div>

    <textarea id="outputArea" readonly placeholder="Processed text will appear here..."></textarea>

    <button id="downloadButton" disabled>Download Cleaned Text</button>
</div>

<script>
    const fileInput = document.getElementById('fileInput');
    const outputArea = document.getElementById('outputArea');
    const downloadButton = document.getElementById('downloadButton');
    const statusDiv = document.getElementById('status');
    const errorDiv = document.getElementById('error');

    let originalFileName = 'cleaned_text.txt';
    let processedContent = '';

    // --- Roman to Arabic Conversion Logic (Unchanged) ---
    function romanToArabic(roman) {
        if (!roman || typeof roman !== 'string') return null;
        roman = roman.toUpperCase().trim();
        // Use a stricter regex that requires word boundaries (\b) to ensure we are trying to convert a standalone numeral
        // This helps prevent matching parts of words, but the main defense is in the calling logic now.
        if (!/^\b[IVXLCDM]+\b$/i.test(roman)) return null;

        const romanMap = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 };
        let result = 0;
        let prevValue = 0;
        let tempRoman = roman.toUpperCase(); // Work with uppercase for map lookup

        for (let i = tempRoman.length - 1; i >= 0; i--) {
            const currentValue = romanMap[tempRoman[i]];
            if (currentValue === undefined) return null; // Invalid character

            if (currentValue < prevValue) {
                result -= currentValue;
            } else {
                result += currentValue;
            }
            prevValue = currentValue;
        }

        // Basic validation check (optional but good)
        // Convert back to Roman (simplified version for validation) and compare
        function arabicToRomanSimpleCheck(num) {
             if (num <= 0 || num >= 4000) return '';
             const val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
             const rom = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];
             let roman = '';
             for (let i = 0; i < val.length; i++) {
                 while (num >= val[i]) {
                     roman += rom[i];
                     num -= val[i];
                 }
             }
             return roman;
         }

        if (result > 0 && result < 4000) {
            // Check if the simple reconversion matches the input (case-insensitive)
            // This catches things like "IIX" which the algorithm might parse but are invalid.
            if (arabicToRomanSimpleCheck(result) === tempRoman) {
                 return result;
            } else {
                 console.warn(`Potential invalid Roman sequence: "${roman}" calculated to ${result}, but re-converts differently.`);
                 return null; // Treat as invalid if reconversion doesn't match
            }
        }
        return null; // Out of range or invalid
    }

    // --- Text Processing Logic ---
    function processText(text) {
        statusDiv.textContent = 'Processing... Applying *** delimiter logic.';
        errorDiv.textContent = ''; // Clear previous errors

        // --- *** NEW: Delimiter Processing Logic *** ---
        const delimiter = '***';
        const parts = text.split(delimiter);

        // We need at least 4 delimiters to define the sections, which means 5 parts after splitting.
        if (parts.length >= 5) {
            // Keep the parts between the second '***' and the second-to-last '***'
            // This corresponds to indices 2 up to (but not including) parts.length - 2
            const contentParts = parts.slice(2, parts.length - 2);
            // Join the kept parts back together using the original delimiter
            // This preserves any '***' that were *within* the content block itself.
            text = contentParts.join(delimiter);
             // Optional: Trim leading/trailing whitespace that might result from the split/join
            text = text.trim();
            statusDiv.textContent = 'Processing... Delimiter logic applied. Starting structural analysis.';
            console.log(`Text extracted between the second and second-to-last "***" delimiters.`);
        } else if (text.includes(delimiter)) {
            // Contains the delimiter, but not enough instances for the rule
            errorDiv.textContent = `Error: Found ${parts.length - 1} instance(s) of "${delimiter}". At least 4 are required for start/end removal logic. Processing skipped.`;
            statusDiv.textContent = 'Processing failed.';
            console.warn(`Found ${parts.length - 1} delimiters. Expected at least 4. Skipping processing.`);
            return ""; // Return empty string as processing cannot proceed as requested
        } else {
             // No delimiters found, proceed with the original text
            statusDiv.textContent = 'Processing... No "***" delimiters found. Starting structural analysis on original text.';
            console.log(`No "***" delimiters found. Proceeding with original text.`);
        }
        // --- End of Delimiter Processing ---


        // If the delimiter logic resulted in empty text, stop here
        if (text === "" && errorDiv.textContent !== '') {
             return "";
        }
         if (text === "") {
            statusDiv.textContent = 'Processing complete (Result is empty).';
            return "";
         }


        statusDiv.textContent = 'Processing... Splitting lines.';
        const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
        const numLines = lines.length;
        const processedData = [];

        statusDiv.textContent = `Processing... Analyzing ${numLines} lines for headings.`;
        // Error div might have been set by delimiter logic, don't clear it here.

        // --- Stage 1: Identify Headings and Process Them (Existing Logic) ---
        // (This part remains unchanged from your original code)
        for (let i = 0; i < numLines; i++) {
            let line = lines[i];
            let trimmedLine = line.trim();
            let isHeading = false;
            let processedLine = trimmedLine;
            let isEmptyLine = false;

            if (trimmedLine === '') {
                processedData.push({ original: line, processed: '', isHeading: false, isEmpty: true });
                continue;
            }

            // --- Heading Detection Heuristics ---

            // 1. Explicit Keywords + Numerals (Roman or Arabic)
            const explicitHeadingRegex = /^(Chapter|Part|Section|Book)\s+(\b[IVXLCDM]+\b|\d+)\s*[:.]?(?:\s+.*)?$/i;
            let match = trimmedLine.match(explicitHeadingRegex);
            if (match) {
                isHeading = true;
                const keyword = match[1];
                const numeralStr = match[2]; // This is either Roman chars or digits
                const restOfLine = trimmedLine.substring(match[0].indexOf(numeralStr) + numeralStr.length).trim();

                if (/^[IVXLCDM]+$/i.test(numeralStr)) {
                    const arabic = romanToArabic(numeralStr);
                    if (arabic !== null) {
                        let separator = '';
                        if (restOfLine) {
                            separator = (/^[:.]/.test(restOfLine)) ? '' : ': ';
                            processedLine = `${keyword.charAt(0).toUpperCase() + keyword.slice(1)} ${arabic}${separator}${restOfLine.replace(/^[:.\s]+/, '')}`;
                        } else {
                             processedLine = `${keyword.charAt(0).toUpperCase() + keyword.slice(1)} ${arabic}`;
                        }
                        console.log(`Converted Explicit Roman: "${trimmedLine}" -> "${processedLine}"`);
                    } else {
                        processedLine = trimmedLine;
                        console.warn(`Invalid Roman numeral "${numeralStr}" found in explicit heading: "${trimmedLine}"`);
                    }
                } else {
                     processedLine = `${keyword.charAt(0).toUpperCase() + keyword.slice(1)} ${numeralStr}${restOfLine ? (restOfLine.startsWith(':') || restOfLine.startsWith('.') ? '' : ': ') + restOfLine.replace(/^[:.\s]+/, '') : ''}`; // Added check for restOfLine content start
                }
            }

            // 2. Roman Numeral Word at Start (Potentially a Heading)
            if (!isHeading) {
                const romanWordStartRegex = /^\b([IVXLCDM]+)\b([:.\s].*)?$/i;
                match = trimmedLine.match(romanWordStartRegex);

                if (match) {
                    const potentialRoman = match[1];
                    const restOfLine = (match[2] || '').trim();
                    let proceedWithConversion = false;

                    if (potentialRoman.toUpperCase() === 'I') {
                        const prevLineEmpty = (i === 0 || lines[i - 1].trim() === '');
                        const nextLineEmpty = (i === numLines - 1 || lines[i + 1].trim() === '');
                        if (restOfLine === '' && prevLineEmpty && nextLineEmpty) {
                            proceedWithConversion = true;
                            console.log(`Treating standalone 'I' between blanks as heading: "${trimmedLine}"`);
                        } else {
                            const firstWordAfterI = restOfLine.split(/\s+/)[0] || '';
                            const commonVerbs = /\b(am|was|will|have|had|do|did|go|went|see|saw|think|like|know|can|could|would|feel|want|is|m|ve|d|ll)\b/i;
                            if (/^[a-z]/.test(restOfLine) || commonVerbs.test(firstWordAfterI)) {
                                proceedWithConversion = false;
                                console.log(`Skipping 'I' conversion (looks like pronoun): "${trimmedLine}"`);
                            } else {
                                const isAllCaps = trimmedLine === trimmedLine.toUpperCase() && /[A-Z]/.test(trimmedLine);
                                if (isAllCaps || (prevLineEmpty && nextLineEmpty)){
                                    proceedWithConversion = true;
                                    console.log(`Treating contextual 'I' as heading: "${trimmedLine}"`);
                                } else {
                                     proceedWithConversion = false;
                                     console.log(`Skipping ambiguous 'I' conversion (weak formatting): "${trimmedLine}"`);
                                }
                            }
                        }
                    } else { // Not 'I'
                        const prevLineEmpty = (i === 0 || lines[i - 1].trim() === '');
                        const nextLineEmpty = (i === numLines - 1 || lines[i + 1].trim() === '');
                        const isAllCaps = trimmedLine === trimmedLine.toUpperCase() && /[A-Z]/.test(trimmedLine);

                        if (isAllCaps || (prevLineEmpty && nextLineEmpty)) {
                            if(romanToArabic(potentialRoman) !== null) {
                                proceedWithConversion = true;
                            } else {
                                console.log(`Skipping conversion (invalid Roman sequence or word?): "${potentialRoman}" in line "${trimmedLine}"`);
                                proceedWithConversion = false;
                            }
                        } else {
                            console.log(`Skipping potential Roman conversion (weak formatting): "${trimmedLine}"`);
                            proceedWithConversion = false;
                        }
                    }

                    if (proceedWithConversion) {
                        const arabic = romanToArabic(potentialRoman);
                        if (arabic !== null) {
                            isHeading = true;
                             let separator = '';
                             let actualRest = restOfLine;
                             if (actualRest) {
                                 if (/^[:.]/.test(actualRest)) {
                                     separator = ''; // Keep existing separator
                                 } else if (actualRest.length > 0) {
                                     separator = ': '; // Add separator if text follows
                                 }
                                 actualRest = actualRest.replace(/^[:.\s]+/, ''); // Clean up start of rest
                             }
                             processedLine = `${arabic}${separator}${actualRest}`;
                            console.log(`Converted Contextual Roman: "${trimmedLine}" -> "${processedLine}"`);
                        } else {
                            processedLine = trimmedLine; // Fallback if conversion failed unexpectedly
                             console.warn(`Contextual Roman conversion failed unexpectedly for "${potentialRoman}" in: "${trimmedLine}"`);
                        }
                    } else {
                         processedLine = trimmedLine; // Keep original if not converting
                    }
                }
            }

            // 3. Implicit Heading Detection (e.g., ALL CAPS line alone)
            if (!isHeading) {
                const isAllCaps = trimmedLine === trimmedLine.toUpperCase()
                                    && trimmedLine.length > 1 // Avoid single characters unless 'I' handled above
                                    && /[A-Z]/.test(trimmedLine) // Must contain letters
                                    && !/^\d+$/.test(trimmedLine); // Not just numbers
                const prevLineEmpty = (i === 0 || lines[i - 1].trim() === '');
                const nextLineEmpty = (i === numLines - 1 || lines[i + 1].trim() === '');

                if (isAllCaps && ((prevLineEmpty && nextLineEmpty) || (i === 0 && nextLineEmpty) || (i === numLines - 1 && prevLineEmpty))) {
                    const romanWordRegex = /^\b[IVXLCDM]+\b$/i;
                    if (!romanWordRegex.test(trimmedLine)) { // Avoid marking standalone Roman numerals as ALL CAPS headings
                         isHeading = true;
                         processedLine = trimmedLine;
                         console.log(`Identified Implicit Heading (ALL CAPS): "${trimmedLine}"`);
                    } else {
                         console.log(`Skipping ALL CAPS heading mark for potential Roman word: "${trimmedLine}"`);
                    }
                }
            }

            // Push the result for this line
            processedData.push({
                original: line,
                processed: processedLine,
                isHeading: isHeading,
                isEmpty: false
            });
        }

        statusDiv.textContent = `Processing... Reconstructing text structure.`;

        // --- Stage 2: Reconstruct Text (Existing Logic) ---
        // (This part remains unchanged from your original code)
        let result = '';
        let currentParagraph = '';
        let previousItemWasHeading = false;
        let pendingBlankLine = true; // Assume we need a blank line at the start unless content follows immediately

        for (let i = 0; i < processedData.length; i++) {
            const item = processedData[i];

            if (item.isHeading) {
                // Finish previous paragraph if any
                if (currentParagraph) {
                    result += currentParagraph.trim() + '\n'; // End paragraph with one newline
                    currentParagraph = '';
                    pendingBlankLine = true; // Ensure blank line after paragraph, before heading
                }
                 // Add blank line before heading if needed
                 if (!pendingBlankLine && result !== '') { // If result has content and no blank line is pending
                     result += '\n';
                 }

                result += '\n' + item.processed + '\n'; // Add blank line, heading, blank line
                pendingBlankLine = true; // We just added a blank line after the heading
                previousItemWasHeading = true;

            } else if (!item.isEmpty) { // Regular text line
                if (currentParagraph === '') {
                    // Starting a new paragraph
                    if (!pendingBlankLine && result !== '' && !previousItemWasHeading) {
                        // Need a paragraph break (double newline) if the last thing wasn't a heading
                        // and we don't already have a pending blank line from an empty line.
                        result += '\n\n';
                    } else if (pendingBlankLine && result !== '') {
                        // If a blank line was pending (from empty line or heading), just add one newline to separate.
                        result += '\n';
                    }
                    currentParagraph = item.processed;
                } else {
                    // Continue existing paragraph
                    if (currentParagraph.endsWith('-')) {
                         // Handle hyphenated words broken across lines
                         currentParagraph = currentParagraph.slice(0, -1) + item.processed;
                    } else {
                         currentParagraph += ' ' + item.processed;
                    }
                }
                pendingBlankLine = false; // Content added, no longer need a blank line immediately
                previousItemWasHeading = false;

            } else { // item.isEmpty is true (Blank line in original)
                 // Finish previous paragraph if any
                 if (currentParagraph) {
                     result += currentParagraph.trim() + '\n';
                     currentParagraph = '';
                 }
                 pendingBlankLine = true; // Mark that we encountered a blank line break
                 // Don't set previousItemWasHeading = true here
            }
        }

        // Add the last paragraph if it exists
        if (currentParagraph) {
             if (pendingBlankLine && result !== '') { // Add separator if needed before last paragraph
                 result += '\n';
             } else if (!pendingBlankLine && result !== '' && !previousItemWasHeading) {
                 result += '\n\n'; // Paragraph break if needed
             }
            result += currentParagraph.trim();
        }

        // --- Final Cleanup Steps (Existing Logic) ---

        // Ensure max one blank line between sections (convert 3+ newlines to 2)
        result = result.replace(/\n{3,}/g, '\n\n');

        // Remove text within square brackets (non-greedy match)
        result = result.replace(/\[.*?\]/g, ''); // Made non-greedy with ?

        // *** Remove all underscore characters ***
        // The 'g' flag ensures all occurrences are replaced.
        result = result.replace(/_/g, '');

        // Clean up extra spaces potentially left after removals or joining
        result = result.replace(/ {2,}/g, ' '); // Replace multiple spaces with single space
        result = result.replace(/ \n/g, '\n'); // Remove space before newline
        result = result.replace(/\n /g, '\n'); // Remove space after newline


        // Final trim of the whole result
        result = result.trim();

        statusDiv.textContent = 'Processing complete.';
        return result;
    }


    // --- Event Listeners (Unchanged) ---
    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) {
            errorDiv.textContent = 'No file selected.';
            return;
        }

        if (file.type !== 'text/plain') {
             errorDiv.textContent = 'Invalid file type. Please upload a .txt file.';
             outputArea.value = '';
             downloadButton.disabled = true;
             processedContent = '';
             statusDiv.textContent = '';
             return;
        }

        originalFileName = file.name.replace(/\.[^/.]+$/, "") + "_cleaned.txt"; // Set download name
        statusDiv.textContent = 'Reading file...';
        errorDiv.textContent = '';
        outputArea.value = ''; // Clear previous output
        downloadButton.disabled = true;

        const reader = new FileReader();

        reader.onload = (e) => {
            try {
                const text = e.target.result;
                statusDiv.textContent = 'File read successfully. Starting processing...';
                // Use setTimeout to allow UI update before potentially long processing
                setTimeout(() => {
                    processedContent = processText(text);
                    // Check if processing failed (e.g., due to delimiter issue)
                    if (processedContent === "" && errorDiv.textContent !== '') {
                         outputArea.value = ''; // Keep output empty if error occurred
                         downloadButton.disabled = true;
                    } else {
                        outputArea.value = processedContent;
                        downloadButton.disabled = processedContent === ''; // Disable download if result is empty
                    }
                    // Status is set within processText
                }, 10); // Small delay
            } catch (err) {
                console.error("Error during processing:", err);
                errorDiv.textContent = `An error occurred during processing: ${err.message}`;
                statusDiv.textContent = 'Processing failed.';
                processedContent = '';
                outputArea.value = '';
                downloadButton.disabled = true;
            }
        };

        reader.onerror = (e) => {
            console.error("File reading error:", e);
            errorDiv.textContent = 'Error reading the file.';
            statusDiv.textContent = 'File reading failed.';
            processedContent = '';
             outputArea.value = '';
            downloadButton.disabled = true;
        };

        reader.readAsText(file);
    });

    downloadButton.addEventListener('click', () => {
        if (!processedContent || downloadButton.disabled) {
            return;
        }

        try {
            const blob = new Blob([processedContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = originalFileName;
            document.body.appendChild(link); // Required for Firefox
            link.click();
            document.body.removeChild(link); // Clean up
            URL.revokeObjectURL(url); // Free up memory
            statusDiv.textContent = 'File downloaded.';
        } catch (err) {
            console.error("Download error:", err);
            errorDiv.textContent = `Failed to initiate download: ${err.message}`;
            statusDiv.textContent = 'Download failed.';
        }
    });
</script>

</body>
</html>
